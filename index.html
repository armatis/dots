<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #be5504;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        svg {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }

        circle {
            cursor: grab;
            transition: r 0.15s ease-out;
        }

        circle:active {
            cursor: grabbing;
        }

        svg.dragging {
            cursor: grabbing;
        }

        svg.dragging circle {
            cursor: grabbing;
        }

        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 14px;
        }

        #controlsToggle {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            transition: background 0.2s;
        }

        #controlsToggle:hover {
            background: #000;
        }

        #controlsPanel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 0;
            margin-top: 10px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            width: 260px;
        }

        #controlsPanel.open {
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            padding: 15px;
        }

        .control-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        .control-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .control-section h3 {
            margin: 0 0 10px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            color: #333;
            font-size: 13px;
        }

        .control-row input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        .control-row .value {
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #000;
            font-size: 13px;
        }

        .control-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .toggle-btn {
            padding: 6px 12px;
            background: transparent;
            color: #000;
            border: 1px solid #000;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }

        .toggle-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .toggle-btn.active {
            background: #000;
            color: #fff;
        }

        .modifier-toggles {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 100%;
            padding: 10px;
            background: transparent;
            color: #000;
            border: 1px solid #000;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            margin-top: 8px;
        }

        .action-btn:first-child {
            margin-top: 0;
        }

        .action-btn:hover {
            background: #000;
            color: #be5504;
        }

        .action-btn.danger {
            border-color: #c00;
            color: #c00;
            margin-top: 16px;
        }

        .action-btn.danger:hover {
            background: #c00;
            color: #fff;
        }

        .kbd-hint {
            font-size: 10px;
            color: #999;
            margin-left: 4px;
        }

        .control-row select {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            background: #fff;
        }

        #freezeIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 8px;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 150;
        }

        #freezeIndicator.active {
            opacity: 1;
        }

        #modifiers {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .modifier {
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 14px;
            font-weight: bold;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.15s, transform 0.15s;
            pointer-events: none;
        }

        .modifier.active {
            opacity: 1;
            transform: translateY(0);
        }

        #helpBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 36px;
            height: 36px;
            background: transparent;
            color: #000;
            border: 1px solid #000;
            border-radius: 50%;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            z-index: 100;
        }

        #helpBtn:hover {
            background: #000;
            color: #be5504;
        }

        #helpModal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        #helpModal.visible {
            opacity: 1;
            visibility: visible;
        }

        #helpContent {
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #helpContent h2 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #000;
        }

        #helpContent dl {
            margin: 0;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px 20px;
        }

        #helpContent dt {
            font-weight: bold;
            color: #000;
        }

        #helpContent dd {
            margin: 0;
            color: #333;
        }

        #helpContent kbd {
            display: inline-block;
            padding: 2px 6px;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }

        #closeHelp {
            margin-top: 20px;
            padding: 8px 20px;
            background: #000;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        #closeHelp:hover {
            background: #333;
        }
    </style>
</head>
<body>
    <svg id="canvas"></svg>

    <div id="modifiers">
        <div id="boostIndicator" class="modifier">BOOST</div>
        <div id="perpetualIndicator" class="modifier">∞ PERPETUAL</div>
    </div>

    <div id="freezeIndicator">❄ FROZEN</div>

    <button id="helpBtn">?</button>

    <div id="helpModal">
        <div id="helpContent">
            <h2>Controls</h2>
            <dl>
                <dt>Create dot(s)</dt>
                <dd>Double-click empty space</dd>

                <dt>Grow dot</dt>
                <dd>Double-click stationary dot</dd>

                <dt>Shrink dot</dt>
                <dd>Hold on dot for 0.8s</dd>

                <dt>Stop moving dot</dt>
                <dd>Double-click moving dot</dd>

                <dt>Drag &amp; throw</dt>
                <dd>Click and drag, release to throw</dd>

                <dt><kbd>A</kbd> + drag</dt>
                <dd>Boost speed (3x faster)</dd>

                <dt><kbd>C</kbd> + release</dt>
                <dd>Perpetual motion (no friction)</dd>

                <dt><kbd>F</kbd></dt>
                <dd>Toggle freeze mode</dd>

                <dt><kbd>S</kbd></dt>
                <dd>Stop all dots</dd>

                <dt><kbd>?</kbd></dt>
                <dd>Toggle this help</dd>

                <dt><kbd>Esc</kbd></dt>
                <dd>Close panels</dd>

                <dt>Settings</dt>
                <dd>Click ⚙ for more options</dd>
            </dl>
            <button id="closeHelp">Got it</button>
        </div>
    </div>

    <div id="controls">
        <button id="controlsToggle">⚙</button>
        <div id="controlsPanel">
            <div class="control-section">
                <h3>Creation</h3>
                <div class="control-row">
                    <label for="countSlider">Dots per click</label>
                    <input type="range" id="countSlider" min="1" max="12" value="1">
                    <span class="value" id="countValue">1</span>
                </div>
            </div>

            <div class="control-section">
                <h3>Modifiers</h3>
                <div class="modifier-toggles">
                    <button class="toggle-btn" id="boostToggle">
                        Boost <span class="kbd-hint">(A)</span>
                    </button>
                    <button class="toggle-btn" id="perpetualToggle">
                        Perpetual <span class="kbd-hint">(C)</span>
                    </button>
                </div>
            </div>

            <div class="control-section">
                <h3>Physics</h3>
                <div class="control-row">
                    <label for="frictionSlider">Friction</label>
                    <input type="range" id="frictionSlider" min="90" max="100" value="98" step="0.5">
                    <span class="value" id="frictionValue">98</span>
                </div>
                <div class="control-row">
                    <label for="bounceSlider">Bounciness</label>
                    <input type="range" id="bounceSlider" min="0" max="100" value="85">
                    <span class="value" id="bounceValue">85</span>
                </div>
            </div>

            <div class="control-section">
                <h3>Mode</h3>
                <div class="control-row">
                    <label for="freezeToggle">Freeze</label>
                    <input type="checkbox" id="freezeToggle">
                </div>
            </div>

            <div class="control-section">
                <h3>Display</h3>
                <div class="control-row">
                    <label for="gridToggle">Show Grid</label>
                    <input type="checkbox" id="gridToggle">
                </div>
                <div class="control-row">
                    <label for="themeSelect">Theme</label>
                    <select id="themeSelect">
                        <option value="orange">Orange</option>
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                        <option value="ocean">Ocean</option>
                        <option value="forest">Forest</option>
                        <option value="sunset">Sunset</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <h3>Actions</h3>
                <button class="action-btn" id="stopAllBtn">Stop All Dots</button>
                <button class="action-btn" id="saveBtn">Save</button>
                <button class="action-btn" id="loadBtn">Load</button>
                <button class="action-btn danger" id="clearBtn">Clear All</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * ========== POTENTIAL OPTIMIZATIONS ==========
         *
         * These optimizations are not currently needed but could be
         * implemented if performance becomes an issue with many dots.
         *
         * 1. SPATIAL PARTITIONING (Collision Detection)
         *    Current: O(n²) - every dot checked against every other dot
         *    Solution: Divide screen into grid cells, only check dots in
         *    neighboring cells. Use cell size ~= largest dot diameter.
         *    Benefit: O(n) average case for evenly distributed dots
         *    When: 100+ dots with noticeable frame drops
         *
         * 2. OBJECT POOLING (Memory/GC)
         *    Current: Trail points created/destroyed frequently
         *    Solution: Pre-allocate pool of trail point objects, reuse them
         *    Benefit: Reduces garbage collection pauses
         *    When: Noticeable stuttering from GC during heavy trail usage
         *
         * 3. CANVAS RENDERING (Rendering)
         *    Current: SVG with D3 data binding
         *    Solution: Switch to Canvas 2D for dots/trails, keep SVG for UI
         *    Benefit: Much faster for many moving objects (no DOM updates)
         *    When: 200+ dots with trails causing frame drops
         *
         * 4. WEB WORKERS (Physics)
         *    Current: Physics runs on main thread
         *    Solution: Offload collision detection to Web Worker
         *    Benefit: Keeps UI responsive during heavy physics
         *    When: Physics calculations blocking input responsiveness
         *
         * 5. BROAD PHASE COLLISION (Collision Detection)
         *    Current: Circle-circle distance check for all pairs
         *    Solution: AABB (bounding box) check first, then precise check
         *    Benefit: AABB check is faster (no sqrt), rejects obvious misses
         *    When: Useful in combination with spatial partitioning
         *
         * 6. TRAIL PATH OPTIMIZATION (Rendering)
         *    Current: Each trail point is a separate SVG circle
         *    Solution: Use single SVG path or Canvas for each dot's trail
         *    Benefit: Fewer DOM nodes, faster rendering
         *    When: Many dots with long trails causing slowdown
         *
         * 7. FRAME SKIPPING (Physics)
         *    Current: Physics runs every animation frame
         *    Solution: Run physics at fixed timestep, interpolate for render
         *    Benefit: Consistent physics regardless of frame rate
         *    When: Physics behaves differently on high/low refresh displays
         */

        // Configuration
        const DEFAULT_RADIUS = 6;
        const MIN_RADIUS = 10;
        const MAX_RADIUS = 200;
        const HOLD_DURATION = 800;
        const GRID_SIZE = DEFAULT_RADIUS;
        const STROKE_WIDTH = 1.5;

        // Physics constants
        const BASE_FRICTION = 0.98;
        const MIN_VELOCITY = 0.1;
        const RESTITUTION = 0.85;
        const COLLISION_ITERATIONS = 4;

        // Freeze state
        let isFrozen = false;

        // Color themes
        const themes = {
            orange: {
                name: 'Orange',
                background: '#be5504',
                dotFill: '#ffffff',
                dotStroke: '#000000',
                ui: '#000000'
            },
            dark: {
                name: 'Dark',
                background: '#1a1a2e',
                dotFill: '#eaeaea',
                dotStroke: '#4a4a6a',
                ui: '#ffffff'
            },
            light: {
                name: 'Light',
                background: '#f5f5f5',
                dotFill: '#333333',
                dotStroke: '#000000',
                ui: '#000000'
            },
            ocean: {
                name: 'Ocean',
                background: '#0a3d62',
                dotFill: '#82ccdd',
                dotStroke: '#ffffff',
                ui: '#ffffff'
            },
            forest: {
                name: 'Forest',
                background: '#1e3d2f',
                dotFill: '#a8e6cf',
                dotStroke: '#2d5a3f',
                ui: '#ffffff'
            },
            sunset: {
                name: 'Sunset',
                background: '#2c1654',
                dotFill: '#ff6b6b',
                dotStroke: '#feca57',
                ui: '#ffffff'
            }
        };
        let currentTheme = 'orange';

        // State
        let dots = [];
        let nextId = 1;
        let holdTimer = null;
        let holdDotId = null;

        // Unified velocity state for ALL moving dots (dragged or thrown)
        let dotVelocities = new Map(); // dotId -> { vx, vy }

        // Drag state
        const DRAG_THRESHOLD = 5;
        const BOOST_MULTIPLIER = 3;
        let isDragging = false;
        let dragDotId = null;
        let dragStartPos = null;
        let dragOriginalPos = null;
        let dragTargetPos = null;
        let isBoostKeyHeld = false;
        let isNoFrictionKeyHeld = false;
        let noFrictionDots = new Set(); // Dots that should never decelerate
        let boostedDots = new Set(); // Dots that were thrown with boost (show trails)

        // Physics loop
        let physicsAnimationId = null;

        // Velocity tracking for throw release
        let velocityHistory = [];
        const VELOCITY_SAMPLES = 5;

        // Collision tracking
        let processedCollisions = new Set();

        // Touch support
        let lastTapTime = 0;
        let lastTapPos = null;
        const DOUBLE_TAP_THRESHOLD = 300;
        const DOUBLE_TAP_DISTANCE = 30;

        // Trail system
        const TRAIL_SPEED_THRESHOLD = 8; // Speed at which trails appear (2x normal movement)
        const TRAIL_MAX_LENGTH = 20; // Max trail points per dot
        const TRAIL_FADE_RATE = 0.05; // How fast trails fade
        let dotTrails = new Map(); // dotId -> [{x, y, opacity, radius}]

        // ========== UNIFIED MASS FUNCTION ==========
        // Area-based mass: (radius / DEFAULT_RADIUS)^2
        function mass(dot) {
            const ratio = dot.radius / DEFAULT_RADIUS;
            return ratio * ratio;
        }

        // ========== SETUP SVG ==========
        const svg = d3.select('#canvas')
            .attr('width', window.innerWidth)
            .attr('height', window.innerHeight);

        const background = svg.append('rect')
            .attr('width', window.innerWidth)
            .attr('height', window.innerHeight)
            .attr('fill', '#be5504');

        // Grid group (hidden by default)
        const gridGroup = svg.append('g')
            .attr('class', 'grid')
            .style('display', 'none');

        function drawGrid() {
            gridGroup.selectAll('*').remove();
            const width = window.innerWidth;
            const height = window.innerHeight;

            for (let x = 0; x <= width; x += GRID_SIZE) {
                gridGroup.append('line')
                    .attr('x1', x).attr('y1', 0)
                    .attr('x2', x).attr('y2', height)
                    .attr('stroke', 'rgba(0,0,0,0.2)')
                    .attr('stroke-width', 0.5);
            }
            for (let y = 0; y <= height; y += GRID_SIZE) {
                gridGroup.append('line')
                    .attr('x1', 0).attr('y1', y)
                    .attr('x2', width).attr('y2', y)
                    .attr('stroke', 'rgba(0,0,0,0.2)')
                    .attr('stroke-width', 0.5);
            }
        }
        drawGrid();

        // Trail group (behind dots)
        const trailGroup = svg.append('g').attr('class', 'trails');

        const dotsGroup = svg.append('g');

        window.addEventListener('resize', () => {
            svg.attr('width', window.innerWidth).attr('height', window.innerHeight);
            background.attr('width', window.innerWidth).attr('height', window.innerHeight);
            drawGrid();
        });

        // ========== UTILITY FUNCTIONS ==========
        const snapToGrid = (x, y) => ({
            x: Math.round(x / GRID_SIZE) * GRID_SIZE,
            y: Math.round(y / GRID_SIZE) * GRID_SIZE
        });

        const wouldOverlap = (x, y, radius, excludeId = null) => {
            return dots.some(dot => {
                if (dot.id === excludeId) return false;
                const dx = dot.x - x;
                const dy = dot.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < radius + dot.radius;
            });
        };

        const findPlacementPosition = (clickX, clickY, newRadius) => {
            if (dots.length === 0) {
                return snapToGrid(clickX, clickY);
            }

            let nearestDot = null;
            let nearestDistance = Infinity;
            for (const dot of dots) {
                const dx = clickX - dot.x;
                const dy = clickY - dot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < nearestDistance) {
                    nearestDistance = dist;
                    nearestDot = dot;
                }
            }

            const touchDistance = nearestDot.radius + Math.max(newRadius, nearestDot.radius);

            if (nearestDistance > touchDistance * 2) {
                return snapToGrid(clickX, clickY);
            }

            const dx = clickX - nearestDot.x;
            const dy = clickY - nearestDot.y;

            if (nearestDistance === 0) {
                return { x: nearestDot.x + touchDistance, y: nearestDot.y };
            }

            const nx = dx / nearestDistance;
            const ny = dy / nearestDistance;

            return snapToGrid(
                nearestDot.x + nx * touchDistance,
                nearestDot.y + ny * touchDistance
            );
        };

        // ========== UNIFIED COLLISION SOLVER ==========
        // Resolves collision between two dots using impulse-based elastic collision
        // Updates velocities and separates positions
        function resolveCollision(dotA, dotB, velA, velB) {
            const dx = dotB.x - dotA.x;
            const dy = dotB.y - dotA.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = dotA.radius + dotB.radius;

            if (dist >= minDist || dist === 0) return false;

            // Collision normal (from A to B)
            const nx = dx / dist;
            const ny = dy / dist;

            // Masses
            const mA = mass(dotA);
            const mB = mass(dotB);
            const totalMass = mA + mB;

            // Relative velocity (A relative to B)
            const relVx = velA.vx - velB.vx;
            const relVy = velA.vy - velB.vy;

            // Relative velocity along collision normal
            const relVelNormal = relVx * nx + relVy * ny;

            // Only resolve if moving toward each other
            if (relVelNormal > 0) {
                // Impulse scalar (use dynamic restitution from slider)
                const restitution = getRestitution();
                const impulse = (1 + restitution) * relVelNormal / (1/mA + 1/mB);

                // Apply impulse to velocities
                velA.vx -= (impulse / mA) * nx;
                velA.vy -= (impulse / mA) * ny;
                velB.vx += (impulse / mB) * nx;
                velB.vy += (impulse / mB) * ny;
            }

            // Positional separation (mass-proportional)
            const overlap = minDist - dist;
            const separationA = overlap * (mB / totalMass);
            const separationB = overlap * (mA / totalMass);

            dotA.x -= nx * separationA;
            dotA.y -= ny * separationA;
            dotB.x += nx * separationB;
            dotB.y += ny * separationB;

            return true;
        }

        // ========== TRAIL SYSTEM ==========
        function updateTrails() {
            const theme = themes[currentTheme];

            // Update trail points for boosted dots only
            for (const dotId of boostedDots) {
                const vel = dotVelocities.get(dotId);
                const dot = dots.find(d => d.id === dotId);
                if (!dot || !vel) {
                    // Dot stopped or was removed
                    boostedDots.delete(dotId);
                    dotTrails.delete(dotId);
                    continue;
                }

                const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);

                if (speed >= TRAIL_SPEED_THRESHOLD) {
                    // Add new trail point
                    if (!dotTrails.has(dotId)) {
                        dotTrails.set(dotId, []);
                    }
                    const trail = dotTrails.get(dotId);
                    trail.unshift({
                        x: dot.x,
                        y: dot.y,
                        opacity: 0.6,
                        radius: dot.radius * 0.8
                    });

                    // Limit trail length
                    if (trail.length > TRAIL_MAX_LENGTH) {
                        trail.pop();
                    }
                } else {
                    // Dot dropped below boost speed - no longer boosted
                    boostedDots.delete(dotId);
                    dotTrails.delete(dotId);
                }
            }

            // Fade trail points for visual effect (while dot is still fast)
            for (const [dotId, trail] of dotTrails) {
                for (let i = trail.length - 1; i >= 0; i--) {
                    trail[i].opacity -= TRAIL_FADE_RATE;
                    trail[i].radius *= 0.95;
                    if (trail[i].opacity <= 0) {
                        trail.splice(i, 1);
                    }
                }
            }

            // Render trails
            const allTrailPoints = [];
            for (const [dotId, trail] of dotTrails) {
                for (const point of trail) {
                    allTrailPoints.push({ ...point, dotId });
                }
            }

            const trailCircles = trailGroup.selectAll('circle')
                .data(allTrailPoints, (d, i) => d.dotId + '-' + i);

            trailCircles.exit().remove();

            trailCircles.enter()
                .append('circle')
                .merge(trailCircles)
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', d => d.radius)
                .attr('fill', theme.dotFill)
                .attr('opacity', d => d.opacity)
                .attr('stroke', 'none');
        }

        // ========== RENDER ==========
        function render() {
            const circles = dotsGroup.selectAll('circle')
                .data(dots, d => d.id);

            circles.exit().remove();

            const theme = themes[currentTheme];
            circles.enter()
                .append('circle')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', d => d.radius)
                .attr('fill', theme.dotFill)
                .attr('stroke', theme.dotStroke)
                .attr('stroke-width', STROKE_WIDTH)
                .on('mousedown', onDotMouseDown)
                .on('mouseup', onDotMouseUp)
                .on('mouseleave', onDotMouseLeave)
                .on('dblclick', onDotDoubleClick)
                .on('touchstart', onDotTouchStart)
                .on('touchend', onDotTouchEnd)
                .on('touchmove', onDotTouchMove);

            circles
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', d => d.radius);
        }

        // ========== DOT CREATION ==========
        function createDot(x, y) {
            const count = parseInt(document.getElementById('countSlider').value, 10);

            if (count === 1) {
                const placement = findPlacementPosition(x, y, DEFAULT_RADIUS);
                if (!wouldOverlap(placement.x, placement.y, DEFAULT_RADIUS)) {
                    dots.push({
                        id: nextId++,
                        x: placement.x,
                        y: placement.y,
                        radius: DEFAULT_RADIUS
                    });
                }
            } else {
                createDotCluster(x, y, count);
            }
            render();
        }

        function createDotCluster(centerX, centerY, count) {
            const diameter = DEFAULT_RADIUS * 2;
            const centerPlacement = findPlacementPosition(centerX, centerY, DEFAULT_RADIUS);
            if (wouldOverlap(centerPlacement.x, centerPlacement.y, DEFAULT_RADIUS)) {
                return;
            }

            const centerDot = {
                id: nextId++,
                x: centerPlacement.x,
                y: centerPlacement.y,
                radius: DEFAULT_RADIUS
            };
            dots.push(centerDot);

            if (count === 1) return;

            let placed = 1;
            let ring = 1;
            let angleOffset = Math.random() * Math.PI * 2;

            while (placed < count) {
                const dotsInRing = ring === 1 ? 6 : ring * 6;
                const angleStep = (Math.PI * 2) / dotsInRing;

                for (let i = 0; i < dotsInRing && placed < count; i++) {
                    const angle = angleOffset + i * angleStep;
                    const distance = diameter * ring;

                    const testX = centerPlacement.x + Math.cos(angle) * distance;
                    const testY = centerPlacement.y + Math.sin(angle) * distance;

                    const snapped = snapToGrid(testX, testY);

                    if (!wouldOverlap(snapped.x, snapped.y, DEFAULT_RADIUS)) {
                        dots.push({
                            id: nextId++,
                            x: snapped.x,
                            y: snapped.y,
                            radius: DEFAULT_RADIUS
                        });
                        placed++;
                    }
                }
                ring++;
                if (ring > 5) break;
            }
        }

        // ========== GROW / SHRINK ==========
        function growDot(id) {
            const dot = dots.find(d => d.id === id);
            if (!dot) return;

            const newRadius = Math.min(dot.radius * 2, MAX_RADIUS);
            const radiusIncrease = newRadius - dot.radius;

            if (!wouldOverlap(dot.x, dot.y, newRadius, id)) {
                dot.radius = newRadius;
                render();
                return;
            }

            // Find dots that would overlap and shift away
            const overlappingDots = dots.filter(other => {
                if (other.id === id) return false;
                const dx = other.x - dot.x;
                const dy = other.y - dot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < newRadius + other.radius;
            });

            if (overlappingDots.length === 0) return;

            let shiftX = 0, shiftY = 0;
            for (const other of overlappingDots) {
                const dx = dot.x - other.x;
                const dy = dot.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    shiftX += dx / dist;
                    shiftY += dy / dist;
                }
            }

            const shiftMag = Math.sqrt(shiftX * shiftX + shiftY * shiftY);
            if (shiftMag === 0) return;
            shiftX /= shiftMag;
            shiftY /= shiftMag;

            const newX = dot.x + shiftX * radiusIncrease;
            const newY = dot.y + shiftY * radiusIncrease;

            if (!wouldOverlap(newX, newY, newRadius, id)) {
                dot.x = newX;
                dot.y = newY;
                dot.radius = newRadius;
                render();
            }
        }

        function shrinkDot(id) {
            const dot = dots.find(d => d.id === id);
            if (!dot) return;

            const newRadius = dot.radius / 2;
            if (newRadius < MIN_RADIUS) {
                dots = dots.filter(d => d.id !== id);
                dotVelocities.delete(id);
                noFrictionDots.delete(id);
                boostedDots.delete(id);
                dotTrails.delete(id);
            } else {
                dot.radius = newRadius;
            }
            render();
        }

        // ========== HOLD TIMER ==========
        function clearHoldTimer() {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            holdDotId = null;
        }

        // ========== DOT EVENT HANDLERS ==========
        function onDotMouseDown(event, d) {
            event.stopPropagation();
            holdDotId = d.id;

            const [mx, my] = d3.pointer(event, svg.node());
            dragStartPos = { x: mx, y: my };
            dragOriginalPos = { x: d.x, y: d.y };
            dragDotId = d.id;
            isDragging = false;

            // Initialize velocity for this dot if not already moving
            if (!dotVelocities.has(d.id)) {
                dotVelocities.set(d.id, { vx: 0, vy: 0 });
            }

            holdTimer = setTimeout(() => {
                if (holdDotId === d.id && !isDragging) {
                    shrinkDot(d.id);
                }
                clearHoldTimer();
            }, HOLD_DURATION);
        }

        function onDotMouseUp(event, d) {
            event.stopPropagation();
            finalizeDrag();
            clearHoldTimer();
        }

        function onDotMouseLeave(event, d) {
            if (!isDragging) {
                clearHoldTimer();
            }
        }

        function onDotDoubleClick(event, d) {
            event.stopPropagation();
            event.preventDefault();
            clearHoldTimer();

            // If dot is moving, stop it
            if (dotVelocities.has(d.id)) {
                const vel = dotVelocities.get(d.id);
                const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
                if (speed > MIN_VELOCITY) {
                    dotVelocities.delete(d.id);
                    noFrictionDots.delete(d.id);
                    const snapped = snapToGrid(d.x, d.y);
                    if (!wouldOverlap(snapped.x, snapped.y, d.radius, d.id)) {
                        d.x = snapped.x;
                        d.y = snapped.y;
                    }
                    render();
                    return;
                }
            }

            growDot(d.id);
        }

        // ========== TOUCH EVENT HANDLERS FOR DOTS ==========
        function onDotTouchStart(event, d) {
            event.preventDefault();
            event.stopPropagation();

            const touch = event.touches[0];
            const [tx, ty] = [touch.clientX, touch.clientY];

            // Check for double-tap
            const now = Date.now();
            if (lastTapTime && now - lastTapTime < DOUBLE_TAP_THRESHOLD && lastTapPos) {
                const dist = Math.sqrt((tx - lastTapPos.x) ** 2 + (ty - lastTapPos.y) ** 2);
                if (dist < DOUBLE_TAP_DISTANCE) {
                    // Double-tap detected
                    lastTapTime = 0;
                    lastTapPos = null;
                    onDotDoubleClick(event, d);
                    return;
                }
            }
            lastTapTime = now;
            lastTapPos = { x: tx, y: ty };

            // Start drag
            holdDotId = d.id;
            const rect = svg.node().getBoundingClientRect();
            dragStartPos = { x: tx - rect.left, y: ty - rect.top };
            dragOriginalPos = { x: d.x, y: d.y };
            dragDotId = d.id;
            isDragging = false;

            if (!dotVelocities.has(d.id)) {
                dotVelocities.set(d.id, { vx: 0, vy: 0 });
            }

            holdTimer = setTimeout(() => {
                if (holdDotId === d.id && !isDragging) {
                    shrinkDot(d.id);
                }
                clearHoldTimer();
            }, HOLD_DURATION);
        }

        function onDotTouchMove(event, d) {
            if (dragDotId === null) return;
            event.preventDefault();

            const touch = event.touches[0];
            const rect = svg.node().getBoundingClientRect();
            const tx = touch.clientX - rect.left;
            const ty = touch.clientY - rect.top;

            const dx = tx - dragStartPos.x;
            const dy = ty - dragStartPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (!isDragging && distance > DRAG_THRESHOLD) {
                isDragging = true;
                clearHoldTimer();
                svg.classed('dragging', true);
                startPhysicsLoop();
            }

            if (isDragging) {
                dragTargetPos = {
                    x: dragOriginalPos.x + dx,
                    y: dragOriginalPos.y + dy
                };
            }
        }

        function onDotTouchEnd(event, d) {
            event.preventDefault();
            finalizeDrag();
            clearHoldTimer();
        }

        // ========== DRAG HANDLING ==========
        svg.on('mousemove', function(event) {
            if (dragDotId === null) return;

            const [mx, my] = d3.pointer(event, svg.node());
            const dx = mx - dragStartPos.x;
            const dy = my - dragStartPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (!isDragging && distance > DRAG_THRESHOLD) {
                isDragging = true;
                clearHoldTimer();
                svg.classed('dragging', true);
                startPhysicsLoop();
            }

            if (isDragging) {
                dragTargetPos = {
                    x: dragOriginalPos.x + dx,
                    y: dragOriginalPos.y + dy
                };
            }
        });

        svg.on('mouseup', function(event) {
            finalizeDrag();
        });

        function finalizeDrag() {
            if (isDragging && dragDotId !== null) {
                // On release, just let physics continue - don't switch modes
                // The dot already has velocity from steering
                const vel = dotVelocities.get(dragDotId);
                if (vel) {
                    // Apply boost multiplier to throw velocity if boost is active
                    if (isBoostKeyHeld) {
                        vel.vx *= BOOST_MULTIPLIER;
                        vel.vy *= BOOST_MULTIPLIER;
                        boostedDots.add(dragDotId);
                    }

                    const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
                    if (speed < MIN_VELOCITY) {
                        // If barely moving, snap to grid and stop
                        const dot = dots.find(d => d.id === dragDotId);
                        if (dot) {
                            const snapped = snapToGrid(dot.x, dot.y);
                            if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                                dot.x = snapped.x;
                                dot.y = snapped.y;
                            }
                        }
                        dotVelocities.delete(dragDotId);
                        noFrictionDots.delete(dragDotId);
                        boostedDots.delete(dragDotId);
                        render();
                    } else if (isNoFrictionKeyHeld) {
                        // Mark this dot as no-friction (perpetual motion)
                        noFrictionDots.add(dragDotId);
                    }
                }
            } else if (dragDotId !== null) {
                // Wasn't dragging, remove velocity if stationary
                const vel = dotVelocities.get(dragDotId);
                if (vel && Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy) < MIN_VELOCITY) {
                    dotVelocities.delete(dragDotId);
                }
            }

            isDragging = false;
            dragDotId = null;
            dragStartPos = null;
            dragOriginalPos = null;
            dragTargetPos = null;
            velocityHistory = [];
            svg.classed('dragging', false);
        }

        // ========== UNIFIED PHYSICS LOOP ==========
        function physicsLoop() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Step 1: Apply drag steering (if dragging)
            if (isDragging && dragDotId !== null && dragTargetPos) {
                const dragDot = dots.find(d => d.id === dragDotId);
                if (dragDot) {
                    let vel = dotVelocities.get(dragDotId);
                    if (!vel) {
                        vel = { vx: 0, vy: 0 };
                        dotVelocities.set(dragDotId, vel);
                    }

                    // Weight-based responsiveness (boosted when A key is held)
                    const weight = mass(dragDot);
                    const baseResponsiveness = Math.min(1, 0.3 / Math.sqrt(weight));
                    const responsiveness = isBoostKeyHeld
                        ? Math.min(1, baseResponsiveness * BOOST_MULTIPLIER)
                        : baseResponsiveness;

                    // Steering: compute desired velocity toward target
                    const toTargetX = dragTargetPos.x - dragDot.x;
                    const toTargetY = dragTargetPos.y - dragDot.y;

                    // The velocity IS the movement toward target (weighted)
                    vel.vx = toTargetX * responsiveness;
                    vel.vy = toTargetY * responsiveness;
                }
            }

            // Step 2: Apply velocities to positions (only dragged dot if frozen)
            for (const [dotId, vel] of dotVelocities) {
                if (isFrozen && dotId !== dragDotId) continue;

                const dot = dots.find(d => d.id === dotId);
                if (!dot) {
                    dotVelocities.delete(dotId);
                    continue;
                }

                dot.x += vel.vx;
                dot.y += vel.vy;
            }

            // Step 3: Boundary collisions (only for dragged dot if frozen)
            for (const [dotId, vel] of dotVelocities) {
                if (isFrozen && dotId !== dragDotId) continue;

                const dot = dots.find(d => d.id === dotId);
                if (!dot) continue;

                if (dot.x - dot.radius < 0) {
                    dot.x = dot.radius;
                    if (!isFrozen) vel.vx *= -0.7;
                } else if (dot.x + dot.radius > width) {
                    dot.x = width - dot.radius;
                    if (!isFrozen) vel.vx *= -0.7;
                }

                if (dot.y - dot.radius < 0) {
                    dot.y = dot.radius;
                    if (!isFrozen) vel.vy *= -0.7;
                } else if (dot.y + dot.radius > height) {
                    dot.y = height - dot.radius;
                    if (!isFrozen) vel.vy *= -0.7;
                }
            }

            // Step 4: Collision resolution
            if (isFrozen) {
                // In freeze mode, only handle collisions for the dragged dot
                // Other dots act as immovable obstacles
                if (isDragging && dragDotId !== null) {
                    const dragDot = dots.find(d => d.id === dragDotId);
                    if (dragDot) {
                        for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {
                            for (const otherDot of dots) {
                                if (otherDot.id === dragDotId) continue;

                                const dx = otherDot.x - dragDot.x;
                                const dy = otherDot.y - dragDot.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const minDist = dragDot.radius + otherDot.radius;

                                if (dist < minDist && dist > 0) {
                                    // Push dragged dot back (other dot is immovable)
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    const overlap = minDist - dist;

                                    dragDot.x -= nx * overlap;
                                    dragDot.y -= ny * overlap;

                                    // Also zero out velocity in that direction
                                    const vel = dotVelocities.get(dragDotId);
                                    if (vel) {
                                        const velDotN = vel.vx * nx + vel.vy * ny;
                                        if (velDotN > 0) {
                                            vel.vx -= velDotN * nx;
                                            vel.vy -= velDotN * ny;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                // Normal physics: full collision resolution
                for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {
                    processedCollisions.clear();

                    for (let i = 0; i < dots.length; i++) {
                        const dotA = dots[i];
                        const velA = dotVelocities.get(dotA.id) || { vx: 0, vy: 0 };

                        for (let j = i + 1; j < dots.length; j++) {
                            const dotB = dots[j];

                            // Skip if neither dot is moving (optimization)
                            const velB = dotVelocities.get(dotB.id) || { vx: 0, vy: 0 };
                            const aMoving = dotVelocities.has(dotA.id);
                            const bMoving = dotVelocities.has(dotB.id);
                            if (!aMoving && !bMoving) continue;

                            const collisionKey = dotA.id + '-' + dotB.id;
                            if (processedCollisions.has(collisionKey)) continue;
                            processedCollisions.add(collisionKey);

                            // Ensure both have velocity entries for collision resolution
                            if (!dotVelocities.has(dotA.id)) {
                                dotVelocities.set(dotA.id, { vx: 0, vy: 0 });
                            }
                            if (!dotVelocities.has(dotB.id)) {
                                dotVelocities.set(dotB.id, { vx: 0, vy: 0 });
                            }

                            const velARef = dotVelocities.get(dotA.id);
                            const velBRef = dotVelocities.get(dotB.id);

                            resolveCollision(dotA, dotB, velARef, velBRef);
                        }
                    }
                }
            }

            // Step 5: Apply friction (skip if frozen, or for dragged/perpetual dots)
            if (!isFrozen) {
                for (const [dotId, vel] of dotVelocities) {
                    if (dotId === dragDotId) continue; // Don't apply friction while dragging
                    if (noFrictionDots.has(dotId)) continue; // Perpetual motion dots

                    const dot = dots.find(d => d.id === dotId);
                    if (!dot) continue;

                    // Mass-based friction: heavier dots have more inertia
                    const m = mass(dot);
                    const baseFriction = getFriction();
                    const friction = 1 - (1 - baseFriction) / Math.sqrt(m);
                    vel.vx *= friction;
                    vel.vy *= friction;

                    // Stop if velocity is very low
                    const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
                    if (speed < MIN_VELOCITY) {
                        // Snap to grid
                        const snapped = snapToGrid(dot.x, dot.y);
                        if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                            dot.x = snapped.x;
                            dot.y = snapped.y;
                        }
                        dotVelocities.delete(dotId);
                    }
                }
            }

            // Step 6: Update trails for fast-moving dots
            updateTrails();

            render();

            // Continue loop if any dots are moving OR dragging is active
            if (dotVelocities.size > 0 || isDragging) {
                physicsAnimationId = requestAnimationFrame(physicsLoop);
            } else {
                physicsAnimationId = null;
            }
        }

        function startPhysicsLoop() {
            if (!physicsAnimationId) {
                physicsAnimationId = requestAnimationFrame(physicsLoop);
            }
        }

        // ========== BACKGROUND HANDLERS ==========
        background.on('dblclick', function(event) {
            const [x, y] = d3.pointer(event);
            createDot(x, y);
        });

        // Touch support for background (double-tap to create)
        background.on('touchstart', function(event) {
            event.preventDefault();
            const touch = event.touches[0];
            const rect = svg.node().getBoundingClientRect();
            const tx = touch.clientX - rect.left;
            const ty = touch.clientY - rect.top;

            const now = Date.now();
            if (lastTapTime && now - lastTapTime < DOUBLE_TAP_THRESHOLD && lastTapPos) {
                const dist = Math.sqrt((touch.clientX - lastTapPos.x) ** 2 + (touch.clientY - lastTapPos.y) ** 2);
                if (dist < DOUBLE_TAP_DISTANCE) {
                    // Double-tap detected - create dot
                    lastTapTime = 0;
                    lastTapPos = null;
                    createDot(tx, ty);
                    return;
                }
            }
            lastTapTime = now;
            lastTapPos = { x: touch.clientX, y: touch.clientY };
        });

        // ========== UI CONTROLS ==========

        // Controls panel toggle
        const controlsToggle = document.getElementById('controlsToggle');
        const controlsPanel = document.getElementById('controlsPanel');
        controlsToggle.addEventListener('click', () => {
            controlsPanel.classList.toggle('open');
        });

        // Dot count slider
        const countSlider = document.getElementById('countSlider');
        const countValue = document.getElementById('countValue');
        countSlider.addEventListener('input', () => {
            countValue.textContent = countSlider.value;
        });

        // Modifier toggles (work alongside keyboard)
        const boostToggle = document.getElementById('boostToggle');
        const perpetualToggle = document.getElementById('perpetualToggle');

        boostToggle.addEventListener('click', () => {
            isBoostKeyHeld = !isBoostKeyHeld;
            boostToggle.classList.toggle('active', isBoostKeyHeld);
            boostIndicator.classList.toggle('active', isBoostKeyHeld);
        });

        perpetualToggle.addEventListener('click', () => {
            isNoFrictionKeyHeld = !isNoFrictionKeyHeld;
            perpetualToggle.classList.toggle('active', isNoFrictionKeyHeld);
            perpetualIndicator.classList.toggle('active', isNoFrictionKeyHeld);
        });

        // Physics sliders
        const frictionSlider = document.getElementById('frictionSlider');
        const frictionValue = document.getElementById('frictionValue');
        frictionSlider.addEventListener('input', () => {
            frictionValue.textContent = frictionSlider.value;
        });

        const bounceSlider = document.getElementById('bounceSlider');
        const bounceValue = document.getElementById('bounceValue');
        bounceSlider.addEventListener('input', () => {
            bounceValue.textContent = bounceSlider.value;
        });

        // Helper to get current physics values
        function getFriction() {
            return parseFloat(frictionSlider.value) / 100;
        }

        function getRestitution() {
            return parseFloat(bounceSlider.value) / 100;
        }

        // Freeze toggle
        const freezeToggle = document.getElementById('freezeToggle');
        const freezeIndicator = document.getElementById('freezeIndicator');
        freezeToggle.addEventListener('change', () => {
            isFrozen = freezeToggle.checked;
            freezeIndicator.classList.toggle('active', isFrozen);
            if (isFrozen) {
                // Stop all dots when freezing
                dotVelocities.clear();
                noFrictionDots.clear();
                boostedDots.clear();
                dotTrails.clear();
                trailGroup.selectAll('*').remove();
            }
        });

        // Grid toggle
        const gridToggle = document.getElementById('gridToggle');
        gridToggle.addEventListener('change', () => {
            gridGroup.style('display', gridToggle.checked ? 'block' : 'none');
        });

        // Theme selector
        const themeSelect = document.getElementById('themeSelect');

        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;

            currentTheme = themeName;

            // Update background
            document.body.style.background = theme.background;
            background.attr('fill', theme.background);

            // Update existing dots
            dotsGroup.selectAll('circle')
                .attr('fill', theme.dotFill)
                .attr('stroke', theme.dotStroke);

            // Update UI elements that need theme colors
            document.querySelectorAll('#modifiers .modifier').forEach(el => {
                el.style.background = theme.ui === '#ffffff' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.8)';
                el.style.color = theme.ui === '#ffffff' ? '#000' : '#fff';
            });

            freezeIndicator.style.background = theme.ui === '#ffffff' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.8)';
            freezeIndicator.style.color = theme.ui === '#ffffff' ? '#000' : '#fff';

            // Update help button
            const helpBtn = document.getElementById('helpBtn');
            helpBtn.style.borderColor = theme.ui;
            helpBtn.style.color = theme.ui;
        }

        themeSelect.addEventListener('change', () => {
            applyTheme(themeSelect.value);
        });

        // Stop all dots
        document.getElementById('stopAllBtn').addEventListener('click', () => {
            for (const [dotId, vel] of dotVelocities) {
                const dot = dots.find(d => d.id === dotId);
                if (dot) {
                    const snapped = snapToGrid(dot.x, dot.y);
                    if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                        dot.x = snapped.x;
                        dot.y = snapped.y;
                    }
                }
            }
            dotVelocities.clear();
            noFrictionDots.clear();
                boostedDots.clear();
            dotTrails.clear();
            trailGroup.selectAll('*').remove();
            render();
        });

        // Save state
        document.getElementById('saveBtn').addEventListener('click', () => {
            const state = {
                dots: dots.map(d => ({ id: d.id, x: d.x, y: d.y, radius: d.radius })),
                nextId: nextId,
                theme: currentTheme,
                settings: {
                    dotsPerClick: countSlider.value,
                    friction: frictionSlider.value,
                    bounciness: bounceSlider.value,
                    showGrid: gridToggle.checked
                }
            };
            localStorage.setItem('dotsAppState', JSON.stringify(state));

            // Visual feedback
            const btn = document.getElementById('saveBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Saved!';
            setTimeout(() => { btn.textContent = originalText; }, 1000);
        });

        // Load state
        document.getElementById('loadBtn').addEventListener('click', () => {
            const saved = localStorage.getItem('dotsAppState');
            if (!saved) {
                const btn = document.getElementById('loadBtn');
                const originalText = btn.textContent;
                btn.textContent = 'No save found';
                setTimeout(() => { btn.textContent = originalText; }, 1000);
                return;
            }

            try {
                const state = JSON.parse(saved);

                // Stop all current motion
                dotVelocities.clear();
                noFrictionDots.clear();
                boostedDots.clear();
                dotTrails.clear();

                // Restore dots
                dots = state.dots || [];
                nextId = state.nextId || (dots.length > 0 ? Math.max(...dots.map(d => d.id)) + 1 : 1);

                // Restore theme
                if (state.theme && themes[state.theme]) {
                    themeSelect.value = state.theme;
                    applyTheme(state.theme);
                }

                // Restore settings
                if (state.settings) {
                    if (state.settings.dotsPerClick) {
                        countSlider.value = state.settings.dotsPerClick;
                        countValue.textContent = state.settings.dotsPerClick;
                    }
                    if (state.settings.friction) {
                        frictionSlider.value = state.settings.friction;
                        frictionValue.textContent = state.settings.friction;
                    }
                    if (state.settings.bounciness) {
                        bounceSlider.value = state.settings.bounciness;
                        bounceValue.textContent = state.settings.bounciness;
                    }
                    if (state.settings.showGrid !== undefined) {
                        gridToggle.checked = state.settings.showGrid;
                        gridGroup.style('display', state.settings.showGrid ? 'block' : 'none');
                    }
                }

                render();

                // Visual feedback
                const btn = document.getElementById('loadBtn');
                const originalText = btn.textContent;
                btn.textContent = 'Loaded!';
                setTimeout(() => { btn.textContent = originalText; }, 1000);
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        });

        // Clear all
        document.getElementById('clearBtn').addEventListener('click', () => {
            dots = [];
            dotVelocities.clear();
            noFrictionDots.clear();
                boostedDots.clear();
            dotTrails.clear();
            trailGroup.selectAll('*').remove();
            render();
        });

        // ========== KEYBOARD CONTROLS ==========
        const boostIndicator = document.getElementById('boostIndicator');
        const perpetualIndicator = document.getElementById('perpetualIndicator');
        const helpModal = document.getElementById('helpModal');

        window.addEventListener('keydown', (e) => {
            if (e.key === 'a' || e.key === 'A') {
                isBoostKeyHeld = true;
                boostIndicator.classList.add('active');
                document.getElementById('boostToggle').classList.add('active');
            }
            if (e.key === 'c' || e.key === 'C') {
                isNoFrictionKeyHeld = true;
                perpetualIndicator.classList.add('active');
                document.getElementById('perpetualToggle').classList.add('active');
            }
            if (e.key === 'f' || e.key === 'F') {
                isFrozen = !isFrozen;
                freezeToggle.checked = isFrozen;
                freezeIndicator.classList.toggle('active', isFrozen);
                if (isFrozen) {
                    dotVelocities.clear();
                    noFrictionDots.clear();
                boostedDots.clear();
                    dotTrails.clear();
                    trailGroup.selectAll('*').remove();
                }
            }
            if (e.key === 's' || e.key === 'S') {
                // Stop all dots
                for (const [dotId, vel] of dotVelocities) {
                    const dot = dots.find(d => d.id === dotId);
                    if (dot) {
                        const snapped = snapToGrid(dot.x, dot.y);
                        if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                            dot.x = snapped.x;
                            dot.y = snapped.y;
                        }
                    }
                }
                dotVelocities.clear();
                noFrictionDots.clear();
                boostedDots.clear();
                dotTrails.clear();
                trailGroup.selectAll('*').remove();
                render();
            }
            if (e.key === '?') {
                helpModal.classList.toggle('visible');
            }
            if (e.key === 'Escape') {
                helpModal.classList.remove('visible');
                controlsPanel.classList.remove('open');
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'a' || e.key === 'A') {
                isBoostKeyHeld = false;
                boostIndicator.classList.remove('active');
                document.getElementById('boostToggle').classList.remove('active');
            }
            if (e.key === 'c' || e.key === 'C') {
                isNoFrictionKeyHeld = false;
                perpetualIndicator.classList.remove('active');
                document.getElementById('perpetualToggle').classList.remove('active');
            }
        });

        // Help modal controls
        document.getElementById('helpBtn').addEventListener('click', () => {
            helpModal.classList.toggle('visible');
        });

        document.getElementById('closeHelp').addEventListener('click', () => {
            helpModal.classList.remove('visible');
        });

        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.remove('visible');
            }
        });

        // Initial render
        render();
    </script>
</body>
</html>
