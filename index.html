<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dots</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #0a3d62;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
      }

      svg {
        display: block;
        cursor: crosshair;
        touch-action: none;
      }

      circle {
        cursor: grab;
        transition: r 0.15s ease-out;
      }

      circle:active {
        cursor: grabbing;
      }

      svg.dragging {
        cursor: grabbing;
      }

      svg.dragging circle {
        cursor: grabbing;
      }

      #controls {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        font-size: 14px;
      }

      #controlsToggle {
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        border: none;
        border-radius: 8px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: auto;
        transition: background 0.2s;
      }

      #controlsToggle:hover {
        background: #000;
      }

      #controlsPanel {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 0;
        margin-top: 10px;
        max-height: 0;
        overflow: hidden;
        transition:
          max-height 0.3s ease,
          padding 0.3s ease;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        width: 260px;
      }

      #controlsPanel.open {
        max-height: calc(100vh - 100px);
        overflow-y: auto;
        padding: 15px;
      }

      .control-section {
        margin-bottom: 15px;
        padding-bottom: 15px;
        border-bottom: 1px solid #ddd;
      }

      .control-section:last-child {
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
      }

      .control-section h3 {
        margin: 0 0 10px 0;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #666;
      }

      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .control-row:last-child {
        margin-bottom: 0;
      }

      .control-row label {
        color: #333;
        font-size: 13px;
      }

      .control-row input[type="range"] {
        width: 100px;
        cursor: pointer;
      }

      .control-row .value {
        min-width: 30px;
        text-align: right;
        font-weight: bold;
        color: #000;
        font-size: 13px;
      }

      .control-row input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .toggle-btn {
        padding: 6px 12px;
        background: transparent;
        color: #000;
        border: 1px solid #000;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        transition:
          background 0.2s,
          color 0.2s;
      }

      .toggle-btn:hover {
        background: rgba(0, 0, 0, 0.1);
      }

      .toggle-btn.active {
        background: #000;
        color: #fff;
      }

      .modifier-toggles {
        display: flex;
        gap: 8px;
      }

      .action-btn {
        width: 100%;
        padding: 10px;
        background: transparent;
        color: #000;
        border: 1px solid #000;
        border-radius: 4px;
        font-size: 13px;
        cursor: pointer;
        transition:
          background 0.2s,
          color 0.2s;
        margin-top: 8px;
      }

      .action-btn:first-child {
        margin-top: 0;
      }

      .action-btn:hover {
        background: #000;
        color: #82ccdd;
      }

      .action-btn.danger {
        border-color: #c00;
        color: #c00;
        margin-top: 16px;
      }

      .action-btn.danger:hover {
        background: #c00;
        color: #fff;
      }

      .kbd-hint {
        font-size: 10px;
        color: #999;
        margin-left: 4px;
      }

      .control-row select {
        padding: 4px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
        cursor: pointer;
        background: #fff;
      }

      #freezeIndicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px 40px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        border-radius: 8px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        font-size: 24px;
        font-weight: bold;
        letter-spacing: 2px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 150;
      }

      #freezeIndicator.active {
        opacity: 1;
      }

      #modifiers {
        position: fixed;
        bottom: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
        z-index: 100;
      }

      .modifier {
        padding: 8px 16px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        border-radius: 4px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        font-size: 14px;
        font-weight: bold;
        opacity: 0;
        transform: translateY(10px);
        transition:
          opacity 0.15s,
          transform 0.15s;
        pointer-events: none;
      }

      .modifier.active {
        opacity: 1;
        transform: translateY(0);
      }

      #helpBtn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 36px;
        height: 36px;
        background: transparent;
        color: #000;
        border: 1px solid #000;
        border-radius: 50%;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        transition:
          background 0.2s,
          color 0.2s;
        z-index: 100;
      }

      #helpBtn:hover {
        background: #000;
        color: #82ccdd;
      }

      #helpModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.2s,
          visibility 0.2s;
      }

      #helpModal.visible {
        opacity: 1;
        visibility: visible;
      }

      #helpContent {
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        max-width: 400px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
      }

      #helpContent h2 {
        margin: 0 0 20px 0;
        font-size: 20px;
        color: #000;
      }

      #helpContent dl {
        margin: 0;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px 20px;
      }

      #helpContent dt {
        font-weight: bold;
        color: #000;
      }

      #helpContent dd {
        margin: 0;
        color: #333;
      }

      #helpContent kbd {
        display: inline-block;
        padding: 2px 6px;
        background: #eee;
        border: 1px solid #ccc;
        border-radius: 3px;
        font-family: monospace;
        font-size: 12px;
      }

      #closeHelp {
        margin-top: 20px;
        padding: 8px 20px;
        background: #000;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      #closeHelp:hover {
        background: #333;
      }

      #chainScoreHUD {
        position: fixed;
        top: 20px;
        left: 20px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #chainScoreHUD.active {
        opacity: 1;
      }

      #chainScoreHUD .score-current {
        font-size: 48px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        line-height: 1;
      }

      #chainScoreHUD .score-label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: rgba(255, 255, 255, 0.7);
      }

      #chainScoreHUD .score-best {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 4px;
      }

      #golfHUD {
        position: fixed;
        top: 20px;
        left: 20px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #golfHUD.active {
        opacity: 1;
      }

      #golfHUD .golf-hole {
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: rgba(255, 255, 255, 0.7);
      }

      #golfHUD .golf-strokes {
        font-size: 48px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        line-height: 1;
      }

      #golfHUD .golf-par {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 4px;
      }

      #golfHUD .golf-total {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 8px;
      }

      #golfHUD .golf-complete {
        font-size: 18px;
        font-weight: bold;
        color: #82ccdd;
        margin-top: 8px;
      }

      #pinballHUD {
        position: fixed;
        top: 20px;
        left: 20px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #pinballHUD.active {
        opacity: 1;
      }

      #pinballHUD .pinball-label {
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: rgba(255, 255, 255, 0.7);
      }

      #pinballHUD .pinball-score {
        font-size: 48px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        line-height: 1;
      }

      #pinballHUD .pinball-best {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 4px;
      }

      #clusterHUD {
        position: fixed;
        top: 20px;
        left: 20px;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #clusterHUD.active {
        opacity: 1;
      }

      #clusterHUD .cluster-label {
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: rgba(255, 255, 255, 0.7);
      }

      #clusterHUD .cluster-timer {
        font-size: 48px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        line-height: 1;
      }

      #clusterHUD .cluster-best {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 4px;
      }

      #clusterHUD .cluster-warning {
        font-size: 18px;
        color: #ff4444;
        font-weight: bold;
        margin-top: 8px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #clusterHUD .cluster-warning.visible {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <svg id="canvas"></svg>

    <div id="chainScoreHUD">
      <div class="score-label">Chain</div>
      <div class="score-current" id="chainScoreValue">0</div>
      <div class="score-best" id="chainBestValue"></div>
    </div>

    <div id="golfHUD">
      <div class="golf-hole" id="golfHoleLabel">Hole 1</div>
      <div class="golf-strokes" id="golfStrokesValue">0</div>
      <div class="golf-par" id="golfParLabel">Par 3</div>
      <div class="golf-total" id="golfTotalLabel"></div>
      <div class="golf-complete" id="golfCompleteLabel"></div>
    </div>

    <div id="pinballHUD">
      <div class="pinball-label">Pinball</div>
      <div class="pinball-score" id="pinballScoreValue">0</div>
      <div class="pinball-best" id="pinballBestLabel">Best: 0</div>
    </div>

    <div id="clusterHUD">
      <div class="cluster-label">Cluster</div>
      <div class="cluster-timer" id="clusterTimerValue">0:00</div>
      <div class="cluster-best" id="clusterBestLabel">Best: 0:00</div>
      <div class="cluster-warning" id="clusterWarning">CRITICAL MASS!</div>
    </div>

    <div id="modifiers">
      <div id="boostIndicator" class="modifier">BOOST</div>
      <div id="perpetualIndicator" class="modifier">∞ PERPETUAL</div>
    </div>

    <div id="freezeIndicator">❄ FROZEN</div>

    <button id="helpBtn">?</button>

    <div id="helpModal">
      <div id="helpContent">
        <h2>Controls</h2>
        <dl>
          <dt>Create dot(s)</dt>
          <dd>Double-click empty space</dd>

          <dt>Grow dot</dt>
          <dd>Double-click stationary dot</dd>

          <dt>Shrink dot</dt>
          <dd>Hold on dot for 0.8s</dd>

          <dt>Stop moving dot</dt>
          <dd>Double-click moving dot</dd>

          <dt>Drag &amp; throw</dt>
          <dd>Click and drag, release to throw</dd>

          <dt><kbd>A</kbd> + drag</dt>
          <dd>Boost speed (3x faster)</dd>

          <dt><kbd>C</kbd> + release</dt>
          <dd>Perpetual motion (no friction)</dd>

          <dt><kbd>F</kbd></dt>
          <dd>Toggle freeze mode</dd>

          <dt><kbd>S</kbd></dt>
          <dd>Stop all dots</dd>

          <dt><kbd>?</kbd></dt>
          <dd>Toggle this help</dd>

          <dt><kbd>Esc</kbd></dt>
          <dd>Close panels</dd>

          <dt>Chain Reaction</dt>
          <dd>Enable in ⚙, place dots, click Start Chain, throw</dd>

          <dt>Settings</dt>
          <dd>Click ⚙ for more options</dd>
        </dl>
        <button id="closeHelp">Got it</button>
      </div>
    </div>

    <div id="controls">
      <button id="controlsToggle">⚙</button>
      <div id="controlsPanel">
        <div class="control-section">
          <h3>Creation</h3>
          <div class="control-row">
            <label for="countSlider">Dots per click</label>
            <input type="range" id="countSlider" min="1" max="12" value="1" />
            <span class="value" id="countValue">1</span>
          </div>
        </div>

        <div class="control-section">
          <h3>Modifiers</h3>
          <div class="modifier-toggles">
            <button class="toggle-btn" id="boostToggle">
              Boost <span class="kbd-hint">(A)</span>
            </button>
            <button class="toggle-btn" id="perpetualToggle">
              Perpetual <span class="kbd-hint">(C)</span>
            </button>
          </div>
        </div>

        <div class="control-section">
          <h3>Physics</h3>
          <div class="control-row">
            <label for="frictionSlider">Friction</label>
            <input
              type="range"
              id="frictionSlider"
              min="90"
              max="100"
              value="98"
              step="0.5"
            />
            <span class="value" id="frictionValue">98</span>
          </div>
          <div class="control-row">
            <label for="bounceSlider">Bounciness</label>
            <input
              type="range"
              id="bounceSlider"
              min="0"
              max="100"
              value="85"
            />
            <span class="value" id="bounceValue">85</span>
          </div>
        </div>

        <div class="control-section">
          <h3>Mode</h3>
          <div class="control-row">
            <label for="freezeToggle">Freeze</label>
            <input type="checkbox" id="freezeToggle" />
          </div>
        </div>

        <div class="control-section">
          <h3>Display</h3>
          <div class="control-row">
            <label for="gridToggle">Show Grid</label>
            <input type="checkbox" id="gridToggle" />
          </div>
          <div class="control-row">
            <label for="themeSelect">Theme</label>
            <select id="themeSelect">
              <option value="orange">Orange</option>
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="ocean" selected>Ocean</option>
              <option value="forest">Forest</option>
              <option value="sunset">Sunset</option>
            </select>
          </div>
        </div>

        <div class="control-section">
          <h3>Game</h3>
          <div class="control-row">
            <label for="chainReactionToggle">Chain Reaction</label>
            <input type="checkbox" id="chainReactionToggle" />
          </div>
          <div class="control-row" id="chainThresholdRow" style="display: none">
            <label for="chainThresholdSlider">Impact threshold</label>
            <input
              type="range"
              id="chainThresholdSlider"
              min="2"
              max="20"
              value="8"
              step="1"
            />
            <span class="value" id="chainThresholdValue">8</span>
          </div>
          <button class="action-btn" id="chainStartBtn" style="display: none">
            Start Chain
          </button>
          <button class="action-btn" id="chainResetBtn" style="display: none">
            Reset Round
          </button>

          <div class="control-row" style="margin-top: 12px">
            <label for="golfToggle">Golf</label>
            <input type="checkbox" id="golfToggle" />
          </div>
          <button class="action-btn" id="golfStartBtn" style="display: none">
            Start Hole
          </button>
          <button class="action-btn" id="golfNextBtn" style="display: none">
            Next Hole
          </button>

          <div class="control-row" style="margin-top: 12px">
            <label for="pinballToggle">Pinball</label>
            <input type="checkbox" id="pinballToggle" />
          </div>
          <button class="action-btn" id="pinballStartBtn" style="display: none">
            Start Round
          </button>

          <div class="control-row" style="margin-top: 12px">
            <label for="clusterToggle">Cluster</label>
            <input type="checkbox" id="clusterToggle" />
          </div>
          <button class="action-btn" id="clusterStartBtn" style="display: none">
            Start
          </button>
        </div>

        <div class="control-section">
          <h3>Actions</h3>
          <button class="action-btn" id="stopAllBtn">Stop All Dots</button>
          <button class="action-btn" id="saveBtn">Save</button>
          <button class="action-btn" id="loadBtn">Load</button>
          <button class="action-btn danger" id="clearBtn">Clear All</button>
        </div>
      </div>
    </div>

    <script>
      /*
       * ========== POTENTIAL OPTIMIZATIONS ==========
       *
       * These optimizations are not currently needed but could be
       * implemented if performance becomes an issue with many dots.
       *
       * 1. SPATIAL PARTITIONING (Collision Detection)
       *    Current: O(n²) - every dot checked against every other dot
       *    Solution: Divide screen into grid cells, only check dots in
       *    neighboring cells. Use cell size ~= largest dot diameter.
       *    Benefit: O(n) average case for evenly distributed dots
       *    When: 100+ dots with noticeable frame drops
       *
       * 2. OBJECT POOLING (Memory/GC)
       *    Current: Trail points created/destroyed frequently
       *    Solution: Pre-allocate pool of trail point objects, reuse them
       *    Benefit: Reduces garbage collection pauses
       *    When: Noticeable stuttering from GC during heavy trail usage
       *
       * 3. CANVAS RENDERING (Rendering)
       *    Current: SVG with D3 data binding
       *    Solution: Switch to Canvas 2D for dots/trails, keep SVG for UI
       *    Benefit: Much faster for many moving objects (no DOM updates)
       *    When: 200+ dots with trails causing frame drops
       *
       * 4. WEB WORKERS (Physics)
       *    Current: Physics runs on main thread
       *    Solution: Offload collision detection to Web Worker
       *    Benefit: Keeps UI responsive during heavy physics
       *    When: Physics calculations blocking input responsiveness
       *
       * 5. BROAD PHASE COLLISION (Collision Detection)
       *    Current: Circle-circle distance check for all pairs
       *    Solution: AABB (bounding box) check first, then precise check
       *    Benefit: AABB check is faster (no sqrt), rejects obvious misses
       *    When: Useful in combination with spatial partitioning
       *
       * 6. TRAIL PATH OPTIMIZATION (Rendering)
       *    Current: Each trail point is a separate SVG circle
       *    Solution: Use single SVG path or Canvas for each dot's trail
       *    Benefit: Fewer DOM nodes, faster rendering
       *    When: Many dots with long trails causing slowdown
       *
       * 7. FRAME SKIPPING (Physics)
       *    Current: Physics runs every animation frame
       *    Solution: Run physics at fixed timestep, interpolate for render
       *    Benefit: Consistent physics regardless of frame rate
       *    When: Physics behaves differently on high/low refresh displays
       */

      // Configuration
      const DEFAULT_RADIUS = 6;
      const MIN_RADIUS = 10;
      const MAX_RADIUS = 200;
      const HOLD_DURATION = 800;
      const GRID_SIZE = DEFAULT_RADIUS;
      const STROKE_WIDTH = 1.5;

      // Physics constants
      const BASE_FRICTION = 0.98;
      const MIN_VELOCITY = 0.1;
      const RESTITUTION = 0.85;
      const COLLISION_ITERATIONS = 4;

      // Freeze state
      let isFrozen = false;

      // Color themes
      const themes = {
        orange: {
          name: "Orange",
          background: "#be5504",
          dotFill: "#ffffff",
          dotStroke: "#000000",
          ui: "#000000",
        },
        dark: {
          name: "Dark",
          background: "#1a1a2e",
          dotFill: "#eaeaea",
          dotStroke: "#4a4a6a",
          ui: "#ffffff",
        },
        light: {
          name: "Light",
          background: "#f5f5f5",
          dotFill: "#333333",
          dotStroke: "#000000",
          ui: "#000000",
        },
        ocean: {
          name: "Ocean",
          background: "#0a3d62",
          dotFill: "#82ccdd",
          dotStroke: "#ffffff",
          ui: "#ffffff",
        },
        forest: {
          name: "Forest",
          background: "#1e3d2f",
          dotFill: "#a8e6cf",
          dotStroke: "#2d5a3f",
          ui: "#ffffff",
        },
        sunset: {
          name: "Sunset",
          background: "#2c1654",
          dotFill: "#ff6b6b",
          dotStroke: "#feca57",
          ui: "#ffffff",
        },
      };
      let currentTheme = "ocean";

      // State
      let dots = [];
      let nextId = 1;
      let holdTimer = null;
      let holdDotId = null;

      // Unified velocity state for ALL moving dots (dragged or thrown)
      let dotVelocities = new Map(); // dotId -> { vx, vy }

      // Drag state
      const DRAG_THRESHOLD = 5;
      const BOOST_MULTIPLIER = 3;
      let isDragging = false;
      let dragDotId = null;
      let dragStartPos = null;
      let dragOriginalPos = null;
      let dragTargetPos = null;
      let isBoostKeyHeld = false;
      let isNoFrictionKeyHeld = false;
      let noFrictionDots = new Set(); // Dots that should never decelerate
      let boostedDots = new Set(); // Dots that were thrown with boost (show trails)

      // Physics loop
      let physicsAnimationId = null;

      // Velocity tracking for throw release
      let velocityHistory = [];
      const VELOCITY_SAMPLES = 5;

      // Collision tracking
      let processedCollisions = new Set();

      // Touch support
      let lastTapTime = 0;
      let lastTapPos = null;
      const DOUBLE_TAP_THRESHOLD = 300;
      const DOUBLE_TAP_DISTANCE = 30;


      // Chain Reaction game state
      const CHAIN_IMPACT_THRESHOLD = 8;
      let chainReactionMode = false;
      let chainReactionActive = false;
      let chainReactionScore = 0;
      let chainReactionBest = 0;
      let chainReactionStartDotId = null;
      let chainWaitingForThrow = false;

      // Golf game state
      let golfMode = false;
      let golfBallId = null;
      let golfTarget = null; // {x, y, radius}
      let golfStrokes = 0;
      let golfPar = 3;
      let golfHoleNumber = 1;
      let golfTotalScore = 0;
      let golfHoleComplete = false;

      // Pinball game state
      let pinballMode = false;
      let pinballBallId = null;
      let pinballBumpers = []; // [{x, y, radius, points, type}]
      let pinballScore = 0;
      let pinballBest = 0;
      let pinballRoundActive = false;

      // Cluster game state
      let clusterMode = false;
      let clusterRoundActive = false;
      let clusterTimeElapsed = 0;
      let clusterBest = 0;
      let clusterTimerId = null;
      let clusterSpawnTimerId = null;
      let clusterDots = []; // [{id, x, y, vx, vy, radius, color, isBlack, clusterId, hitsTaken}]
      let clusterNextId = 1;
      let clusterGroups = new Map(); // clusterId -> [dotIds]
      let clusterNextGroupId = 1;
      let clusterSpawnInterval = 2000;
      let clusterDragDotId = null; // ID of black dot being dragged
      let clusterDragStartPos = null; // {x, y} of drag start
      let clusterDragOriginalPos = null; // Original dot position
      let clusterDragLastPos = null; // Last position for velocity calc
      let clusterDragVelocity = { vx: 0, vy: 0 }; // Accumulated velocity
      const CLUSTER_COLORS = ["#ffffff"]; // White cancer cells
      const CLUSTER_GRAVITY = 0.8; // Strong attraction between cells
      const CLUSTER_MERGE_SIZE = 4; // Dots needed to merge into larger

      // ========== UNIFIED MASS FUNCTION ==========
      // Area-based mass: (radius / DEFAULT_RADIUS)^2
      function mass(dot) {
        const ratio = dot.radius / DEFAULT_RADIUS;
        return ratio * ratio;
      }

      // ========== SETUP SVG ==========
      const svg = d3
        .select("#canvas")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

      const background = svg
        .append("rect")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight)
        .attr("fill", "#0a3d62");

      // Grid group (hidden by default)
      const gridGroup = svg
        .append("g")
        .attr("class", "grid")
        .style("display", "none");

      function drawGrid() {
        gridGroup.selectAll("*").remove();
        const width = window.innerWidth;
        const height = window.innerHeight;

        for (let x = 0; x <= width; x += GRID_SIZE) {
          gridGroup
            .append("line")
            .attr("x1", x)
            .attr("y1", 0)
            .attr("x2", x)
            .attr("y2", height)
            .attr("stroke", "rgba(0,0,0,0.2)")
            .attr("stroke-width", 0.5);
        }
        for (let y = 0; y <= height; y += GRID_SIZE) {
          gridGroup
            .append("line")
            .attr("x1", 0)
            .attr("y1", y)
            .attr("x2", width)
            .attr("y2", y)
            .attr("stroke", "rgba(0,0,0,0.2)")
            .attr("stroke-width", 0.5);
        }
      }
      drawGrid();

      // Golf target group (behind everything)
      const golfTargetGroup = svg.append("g").attr("class", "golf-target");

      // Pinball bumper group
      const pinballBumperGroup = svg
        .append("g")
        .attr("class", "pinball-bumpers");

      // Cluster dots group
      const clusterDotsGroup = svg.append("g").attr("class", "cluster-dots");


      const dotsGroup = svg.append("g");

      window.addEventListener("resize", () => {
        svg.attr("width", window.innerWidth).attr("height", window.innerHeight);
        background
          .attr("width", window.innerWidth)
          .attr("height", window.innerHeight);
        drawGrid();
      });

      // ========== UTILITY FUNCTIONS ==========
      const snapToGrid = (x, y) => ({
        x: Math.round(x / GRID_SIZE) * GRID_SIZE,
        y: Math.round(y / GRID_SIZE) * GRID_SIZE,
      });

      const wouldOverlap = (x, y, radius, excludeId = null) => {
        return dots.some((dot) => {
          if (dot.id === excludeId) return false;
          const dx = dot.x - x;
          const dy = dot.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < radius + dot.radius;
        });
      };

      const findPlacementPosition = (clickX, clickY, newRadius) => {
        if (dots.length === 0) {
          return snapToGrid(clickX, clickY);
        }

        let nearestDot = null;
        let nearestDistance = Infinity;
        for (const dot of dots) {
          const dx = clickX - dot.x;
          const dy = clickY - dot.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDistance) {
            nearestDistance = dist;
            nearestDot = dot;
          }
        }

        const touchDistance =
          nearestDot.radius + Math.max(newRadius, nearestDot.radius);

        if (nearestDistance > touchDistance * 2) {
          return snapToGrid(clickX, clickY);
        }

        const dx = clickX - nearestDot.x;
        const dy = clickY - nearestDot.y;

        if (nearestDistance === 0) {
          return { x: nearestDot.x + touchDistance, y: nearestDot.y };
        }

        const nx = dx / nearestDistance;
        const ny = dy / nearestDistance;

        return snapToGrid(
          nearestDot.x + nx * touchDistance,
          nearestDot.y + ny * touchDistance,
        );
      };

      // ========== UNIFIED COLLISION SOLVER ==========
      // Resolves collision between two dots using impulse-based elastic collision
      // Updates velocities and separates positions
      function resolveCollision(dotA, dotB, velA, velB) {
        const dx = dotB.x - dotA.x;
        const dy = dotB.y - dotA.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = dotA.radius + dotB.radius;

        if (dist >= minDist || dist === 0) return false;

        // Collision normal (from A to B)
        const nx = dx / dist;
        const ny = dy / dist;

        // Masses
        const mA = mass(dotA);
        const mB = mass(dotB);
        const totalMass = mA + mB;

        // Relative velocity (A relative to B)
        const relVx = velA.vx - velB.vx;
        const relVy = velA.vy - velB.vy;

        // Relative velocity along collision normal
        const relVelNormal = relVx * nx + relVy * ny;

        // Only resolve if moving toward each other
        if (relVelNormal > 0) {
          // Impulse scalar (use dynamic restitution from slider)
          const restitution = getRestitution();
          const impulse =
            ((1 + restitution) * relVelNormal) / (1 / mA + 1 / mB);

          // Apply impulse to velocities
          velA.vx -= (impulse / mA) * nx;
          velA.vy -= (impulse / mA) * ny;
          velB.vx += (impulse / mB) * nx;
          velB.vy += (impulse / mB) * ny;

          // Chain Reaction: propagate boost on hard collision
          if (chainReactionMode && chainReactionActive) {
            const impactSpeed = Math.abs(relVelNormal);
            const threshold = getChainThreshold();

            if (impactSpeed >= threshold) {
              const aIsBoosted = boostedDots.has(dotA.id);
              const bIsBoosted = boostedDots.has(dotB.id);

              if (aIsBoosted && !bIsBoosted) {
                boostedDots.add(dotB.id);
                chainReactionScore++;
                updateChainScoreDisplay();
              }
              if (bIsBoosted && !aIsBoosted) {
                boostedDots.add(dotA.id);
                chainReactionScore++;
                updateChainScoreDisplay();
              }
            }
          }
        }

        // Positional separation (mass-proportional)
        const overlap = minDist - dist;
        const separationA = overlap * (mB / totalMass);
        const separationB = overlap * (mA / totalMass);

        dotA.x -= nx * separationA;
        dotA.y -= ny * separationA;
        dotB.x += nx * separationB;
        dotB.y += ny * separationB;

        return true;
      }


      // ========== CHAIN REACTION GAME ==========
      function getChainThreshold() {
        const slider = document.getElementById("chainThresholdSlider");
        return slider ? parseFloat(slider.value) : CHAIN_IMPACT_THRESHOLD;
      }

      function startChainReactionRound(startDotId) {
        chainReactionActive = true;
        chainReactionScore = 1; // The thrown dot counts
        chainReactionStartDotId = startDotId;
        updateChainScoreDisplay();
      }

      function endChainReactionRound() {
        chainReactionActive = false;
        if (chainReactionScore > chainReactionBest) {
          chainReactionBest = chainReactionScore;
        }
        updateChainScoreDisplay();
        chainReactionStartDotId = null;
      }

      function resetChainReaction() {
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();

        chainReactionActive = false;
        chainReactionScore = 0;
        chainReactionStartDotId = null;
        updateChainScoreDisplay();
        render();
      }

      function updateChainScoreDisplay() {
        const scoreEl = document.getElementById("chainScoreValue");
        const bestEl = document.getElementById("chainBestValue");
        if (!scoreEl) return;

        scoreEl.textContent = chainReactionScore;

        const parts = [];
        if (chainReactionBest > 0) {
          parts.push("Best: " + chainReactionBest);
        }
        if (chainReactionActive) {
          parts.push(dots.length + " dots");
        } else if (chainReactionScore > 0) {
          parts.push("Hit " + chainReactionScore + "/" + dots.length);
        }
        bestEl.textContent = parts.join(" | ");
      }

      // ========== GOLF GAME ==========
      function startGolfHole() {
        // Clear any existing dots
        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();

        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 100;

        // Place target randomly on right side
        golfTarget = {
          x: width - margin - Math.random() * (width / 3),
          y: margin + Math.random() * (height - margin * 2),
          radius: 40,
        };

        // Calculate par based on distance from start
        const startX = margin;
        const startY = height / 2;
        const dist = Math.sqrt(
          (golfTarget.x - startX) ** 2 + (golfTarget.y - startY) ** 2,
        );
        if (dist < 300) golfPar = 2;
        else if (dist < 500) golfPar = 3;
        else golfPar = 4;

        // Create ball at start position
        const ballDot = {
          id: nextId++,
          x: startX,
          y: startY,
          radius: DEFAULT_RADIUS,
        };
        dots.push(ballDot);
        golfBallId = ballDot.id;

        golfStrokes = 0;
        golfHoleComplete = false;

        renderGolfTarget();
        updateGolfHUD();
        render();

        // Show/hide buttons
        document.getElementById("golfStartBtn").style.display = "none";
        document.getElementById("golfNextBtn").style.display = "none";
      }

      function endGolfHole() {
        golfHoleComplete = true;
        const diff = golfStrokes - golfPar;
        golfTotalScore += diff;

        updateGolfHUD();

        // Show next hole button
        document.getElementById("golfNextBtn").style.display = "block";
      }

      function nextGolfHole() {
        golfHoleNumber++;
        startGolfHole();
      }

      function resetGolf() {
        golfBallId = null;
        golfTarget = null;
        golfStrokes = 0;
        golfPar = 3;
        golfHoleNumber = 1;
        golfTotalScore = 0;
        golfHoleComplete = false;

        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        golfTargetGroup.selectAll("*").remove();

        render();
        updateGolfHUD();
      }

      function checkGolfWin() {
        if (!golfMode || !golfBallId || !golfTarget || golfHoleComplete) return;

        const ball = dots.find((d) => d.id === golfBallId);
        if (!ball) return;

        // Ball must be stopped (not in velocities map)
        if (dotVelocities.has(golfBallId)) return;

        // Check if ball center is within target
        const dx = ball.x - golfTarget.x;
        const dy = ball.y - golfTarget.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= golfTarget.radius) {
          endGolfHole();
        }
      }

      function renderGolfTarget() {
        golfTargetGroup.selectAll("*").remove();
        if (!golfTarget) return;

        // Outer ring
        golfTargetGroup
          .append("circle")
          .attr("cx", golfTarget.x)
          .attr("cy", golfTarget.y)
          .attr("r", golfTarget.radius)
          .attr("fill", "rgba(255, 255, 255, 0.1)")
          .attr("stroke", "#fff")
          .attr("stroke-width", 3)
          .attr("stroke-dasharray", "10,5");

        // Inner ring
        golfTargetGroup
          .append("circle")
          .attr("cx", golfTarget.x)
          .attr("cy", golfTarget.y)
          .attr("r", golfTarget.radius * 0.5)
          .attr("fill", "none")
          .attr("stroke", "rgba(255,255,255,0.5)")
          .attr("stroke-width", 2);

        // Center dot
        golfTargetGroup
          .append("circle")
          .attr("cx", golfTarget.x)
          .attr("cy", golfTarget.y)
          .attr("r", 5)
          .attr("fill", "#fff");
      }

      function updateGolfHUD() {
        const holeLabel = document.getElementById("golfHoleLabel");
        const strokesValue = document.getElementById("golfStrokesValue");
        const parLabel = document.getElementById("golfParLabel");
        const totalLabel = document.getElementById("golfTotalLabel");
        const completeLabel = document.getElementById("golfCompleteLabel");

        if (!holeLabel) return;

        holeLabel.textContent = "Hole " + golfHoleNumber;
        strokesValue.textContent = golfStrokes;
        parLabel.textContent = "Par " + golfPar;

        if (golfTotalScore === 0) {
          totalLabel.textContent = "";
        } else if (golfTotalScore > 0) {
          totalLabel.textContent = "Total: +" + golfTotalScore;
        } else {
          totalLabel.textContent = "Total: " + golfTotalScore;
        }

        if (golfHoleComplete) {
          const diff = golfStrokes - golfPar;
          let msg = "";
          if (diff === -2) msg = "Eagle!";
          else if (diff === -1) msg = "Birdie!";
          else if (diff === 0) msg = "Par";
          else if (diff === 1) msg = "Bogey";
          else if (diff === 2) msg = "Double Bogey";
          else if (diff > 2) msg = "+" + diff;
          else msg = diff.toString();
          completeLabel.textContent = msg;
        } else {
          completeLabel.textContent = "";
        }
      }

      // ========== PINBALL GAME ==========
      function startPinballRound() {
        // Clear any existing dots
        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();

        // Place bumpers
        placeBumpers();
        renderBumpers();

        // Create ball at start position
        const width = window.innerWidth;
        const height = window.innerHeight;
        const ballDot = {
          id: nextId++,
          x: 100,
          y: height / 2,
          radius: DEFAULT_RADIUS,
        };
        dots.push(ballDot);
        pinballBallId = ballDot.id;

        pinballScore = 0;
        pinballRoundActive = false; // Will become active on first throw

        updatePinballHUD();
        render();

        document.getElementById("pinballStartBtn").textContent = "Start Round";
      }

      function endPinballRound() {
        pinballRoundActive = false;
        if (pinballScore > pinballBest) {
          pinballBest = pinballScore;
        }
        updatePinballHUD();
        document.getElementById("pinballStartBtn").style.display = "block";
      }

      function resetPinball() {
        pinballBallId = null;
        pinballBumpers = [];
        pinballScore = 0;
        pinballRoundActive = false;

        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        pinballBumperGroup.selectAll("*").remove();

        render();
        updatePinballHUD();
      }

      function placeBumpers() {
        pinballBumpers = [];
        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 120;
        const bumperRadius = 30;

        // Place 5-8 bumpers
        const count = 5 + Math.floor(Math.random() * 4);

        for (let i = 0; i < count; i++) {
          let attempts = 0;
          let placed = false;

          while (!placed && attempts < 50) {
            const x = margin + Math.random() * (width - margin * 2);
            const y = margin + Math.random() * (height - margin * 2);

            // Check overlap with other bumpers
            let overlaps = false;
            for (const other of pinballBumpers) {
              const dist = Math.sqrt((x - other.x) ** 2 + (y - other.y) ** 2);
              if (dist < bumperRadius * 2 + 40) {
                overlaps = true;
                break;
              }
            }

            if (!overlaps) {
              const isBonus = Math.random() < 0.2; // 20% chance of bonus
              pinballBumpers.push({
                x,
                y,
                radius: bumperRadius,
                points: isBonus ? 25 : 10,
                type: isBonus ? "bonus" : "standard",
              });
              placed = true;
            }
            attempts++;
          }
        }
      }

      function renderBumpers() {
        pinballBumperGroup.selectAll("*").remove();

        for (const bumper of pinballBumpers) {
          // Outer glow
          pinballBumperGroup
            .append("circle")
            .attr("cx", bumper.x)
            .attr("cy", bumper.y)
            .attr("r", bumper.radius + 5)
            .attr("fill", "none")
            .attr(
              "stroke",
              bumper.type === "bonus"
                ? "rgba(255, 215, 0, 0.5)"
                : "rgba(255, 255, 255, 0.3)",
            )
            .attr("stroke-width", 3);

          // Main bumper
          pinballBumperGroup
            .append("circle")
            .attr("cx", bumper.x)
            .attr("cy", bumper.y)
            .attr("r", bumper.radius)
            .attr("fill", bumper.type === "bonus" ? "#ffd700" : "#fff")
            .attr("stroke", bumper.type === "bonus" ? "#b8860b" : "#ccc")
            .attr("stroke-width", 2);

          // Center point value
          pinballBumperGroup
            .append("text")
            .attr("x", bumper.x)
            .attr("y", bumper.y + 5)
            .attr("text-anchor", "middle")
            .attr("fill", bumper.type === "bonus" ? "#000" : "#333")
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .text(bumper.points);
        }
      }

      function updatePinballHUD() {
        const scoreValue = document.getElementById("pinballScoreValue");
        const bestLabel = document.getElementById("pinballBestLabel");

        if (!scoreValue) return;

        scoreValue.textContent = pinballScore;
        bestLabel.textContent = "Best: " + pinballBest;
      }

      // ========== CLUSTER GAME ==========
      function startClusterRound() {
        // Clear existing state
        clusterDots = [];
        clusterGroups.clear();
        clusterNextId = 1;
        clusterNextGroupId = 1;
        clusterTimeElapsed = 0;
        clusterSpawnInterval = 2000;
        clusterDotsGroup.selectAll("*").remove();

        clusterRoundActive = true;

        // Create initial black dot in center
        const width = window.innerWidth;
        const height = window.innerHeight;
        clusterDots.push({
          id: clusterNextId++,
          x: width / 2,
          y: height / 2,
          vx: 0,
          vy: 0,
          radius: 15,
          color: "#222222",
          isBlack: true,
          clusterId: null,
          hitsTaken: 0,
        });

        updateClusterHUD();
        renderClusterDots();

        // Start timer
        clusterTimerId = setInterval(clusterTick, 1000);

        // Start spawning colored dots
        clusterSpawnTimerId = setTimeout(spawnClusterDot, 1000);

        document.getElementById("clusterStartBtn").style.display = "none";

        // Start physics loop
        startPhysicsLoop();
      }

      function endClusterRound() {
        clusterRoundActive = false;

        if (clusterTimerId) {
          clearInterval(clusterTimerId);
          clusterTimerId = null;
        }

        if (clusterSpawnTimerId) {
          clearTimeout(clusterSpawnTimerId);
          clusterSpawnTimerId = null;
        }

        if (clusterTimeElapsed > clusterBest) {
          clusterBest = clusterTimeElapsed;
        }

        updateClusterHUD();
        document.getElementById("clusterStartBtn").style.display = "block";
        document.getElementById("clusterStartBtn").textContent = "Try Again";
      }

      function resetCluster() {
        clusterRoundActive = false;

        if (clusterTimerId) {
          clearInterval(clusterTimerId);
          clusterTimerId = null;
        }

        if (clusterSpawnTimerId) {
          clearTimeout(clusterSpawnTimerId);
          clusterSpawnTimerId = null;
        }

        clusterDots = [];
        clusterGroups.clear();
        clusterNextId = 1;
        clusterNextGroupId = 1;
        clusterTimeElapsed = 0;
        clusterSpawnInterval = 2000;

        clusterDotsGroup.selectAll("*").remove();
        updateClusterHUD();
      }

      function spawnClusterDot() {
        if (!clusterRoundActive) return;

        const width = window.innerWidth;
        const height = window.innerHeight;
        const radius = 15;

        // Spawn from random edge
        const edge = Math.floor(Math.random() * 4);
        let x, y, vx, vy;
        const speed = 0.5 + Math.random() * 0.5;

        switch (edge) {
          case 0: // top
            x = Math.random() * width;
            y = -radius;
            vx = (Math.random() - 0.5) * 2;
            vy = speed;
            break;
          case 1: // right
            x = width + radius;
            y = Math.random() * height;
            vx = -speed;
            vy = (Math.random() - 0.5) * 2;
            break;
          case 2: // bottom
            x = Math.random() * width;
            y = height + radius;
            vx = (Math.random() - 0.5) * 2;
            vy = -speed;
            break;
          case 3: // left
            x = -radius;
            y = Math.random() * height;
            vx = speed;
            vy = (Math.random() - 0.5) * 2;
            break;
        }

        // Random color
        const color =
          CLUSTER_COLORS[Math.floor(Math.random() * CLUSTER_COLORS.length)];

        clusterDots.push({
          id: clusterNextId++,
          x,
          y,
          vx,
          vy,
          radius,
          color,
          isBlack: false,
          clusterId: null,
          hitsTaken: 0,
        });

        // Schedule next spawn (gets faster over time)
        clusterSpawnTimerId = setTimeout(spawnClusterDot, clusterSpawnInterval);
      }

      function updateClusterPhysics() {
        if (!clusterRoundActive) return;

        const width = window.innerWidth;
        const height = window.innerHeight;

        // Move all dots
        for (const dot of clusterDots) {
          // Skip dot being dragged
          if (dot.id === clusterDragDotId) continue;

          if (!dot.isBlack) {
            // Colored dots: Apply gravity toward same-colored dots
            for (const other of clusterDots) {
              if (
                other.id === dot.id ||
                other.isBlack ||
                other.color !== dot.color
              )
                continue;

              const dx = other.x - dot.x;
              const dy = other.y - dot.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist > 0 && dist < 300) {
                const force = CLUSTER_GRAVITY / (dist * 0.1);
                dot.vx += (dx / dist) * force;
                dot.vy += (dy / dist) * force;
              }
            }
          }

          // Apply friction
          dot.vx *= 0.98;
          dot.vy *= 0.98;

          // Limit speed (slower for larger dots)
          const maxSpeed = dot.isBlack ? 25 : 3 / (dot.radius / 15);
          const speed = Math.sqrt(dot.vx * dot.vx + dot.vy * dot.vy);
          if (speed > maxSpeed) {
            dot.vx = (dot.vx / speed) * maxSpeed;
            dot.vy = (dot.vy / speed) * maxSpeed;
          }

          // Move
          dot.x += dot.vx;
          dot.y += dot.vy;

          // Bounce off walls
          if (dot.x - dot.radius < 0) {
            dot.x = dot.radius;
            dot.vx *= -0.8;
          }
          if (dot.x + dot.radius > width) {
            dot.x = width - dot.radius;
            dot.vx *= -0.8;
          }
          if (dot.y - dot.radius < 0) {
            dot.y = dot.radius;
            dot.vy *= -0.8;
          }
          if (dot.y + dot.radius > height) {
            dot.y = height - dot.radius;
            dot.vy *= -0.8;
          }
        }

        // Check for same-color clustering
        checkClusterCollisions();

        // Check for black dot attacks
        checkBlackDotAttacks();

        // Check lose condition
        checkClusterLoseCondition();
      }

      function checkClusterCollisions() {
        const toMerge = []; // pairs of dots to merge

        for (let i = 0; i < clusterDots.length; i++) {
          const a = clusterDots[i];
          if (a.isBlack) continue;

          for (let j = i + 1; j < clusterDots.length; j++) {
            const b = clusterDots[j];
            if (b.isBlack || a.color !== b.color) continue;
            if (a.radius !== b.radius) continue; // Only same-size can cluster

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = a.radius + b.radius;

            if (dist < minDist * 0.9) {
              toMerge.push([a, b]);
            }
          }
        }

        // Process merges
        for (const [a, b] of toMerge) {
          if (!clusterDots.includes(a) || !clusterDots.includes(b)) continue;

          // Find all same-color, same-size dots touching this cluster
          const cluster = [a, b];
          let changed = true;
          while (changed) {
            changed = false;
            for (const dot of clusterDots) {
              if (cluster.includes(dot) || dot.isBlack) continue;
              if (dot.color !== a.color || dot.radius !== a.radius) continue;

              for (const c of cluster) {
                const dx = dot.x - c.x;
                const dy = dot.y - c.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < (dot.radius + c.radius) * 0.95) {
                  cluster.push(dot);
                  changed = true;
                  break;
                }
              }
            }
          }

          // If we have 4+ dots, merge into larger dot
          if (cluster.length >= CLUSTER_MERGE_SIZE) {
            const avgX = cluster.reduce((s, d) => s + d.x, 0) / cluster.length;
            const avgY = cluster.reduce((s, d) => s + d.y, 0) / cluster.length;

            // Remove clustered dots
            for (const dot of cluster) {
              const idx = clusterDots.indexOf(dot);
              if (idx !== -1) clusterDots.splice(idx, 1);
            }

            // Create larger dot
            const newRadius = a.radius * 2;
            clusterDots.push({
              id: clusterNextId++,
              x: avgX,
              y: avgY,
              vx: 0,
              vy: 0,
              radius: newRadius,
              color: a.color,
              isBlack: false,
              clusterId: null,
              hitsTaken: 0,
            });
          }
        }
      }

      function checkBlackDotAttacks() {
        const blackDots = clusterDots.filter((d) => d.isBlack);
        const coloredDots = clusterDots.filter((d) => !d.isBlack);

        for (const black of blackDots) {
          // Only deal damage if black dot is moving (thrown, not dragged)
          const blackSpeed = Math.sqrt(
            black.vx * black.vx + black.vy * black.vy,
          );
          if (blackSpeed < 2) continue; // Must be moving to attack

          for (const colored of coloredDots) {
            const dx = colored.x - black.x;
            const dy = colored.y - black.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = black.radius + colored.radius;

            if (dist < minDist * 0.9) {
              // Calculate hits needed: same size = 1, 2x size = 4, 4x size = 16
              const sizeRatio = colored.radius / black.radius;
              const hitsNeeded =
                sizeRatio <= 1 ? 1 : Math.round(sizeRatio * sizeRatio);

              colored.hitsTaken++;

              // Bounce black dot back (reverse velocity)
              const nx = dx / dist;
              const ny = dy / dist;
              black.x = colored.x - nx * (minDist + 5);
              black.y = colored.y - ny * (minDist + 5);
              black.vx = -black.vx * 0.5;
              black.vy = -black.vy * 0.5;

              if (colored.hitsTaken >= hitsNeeded) {
                // Destroy colored dot (just remove it)
                const idx = clusterDots.indexOf(colored);
                if (idx !== -1) clusterDots.splice(idx, 1);
              }
              break; // One collision per black dot per frame
            }
          }
        }
      }

      function mergeBlackDots(a, b) {
        if (!clusterDots.includes(a) || !clusterDots.includes(b)) return;

        const avgX = (a.x + b.x) / 2;
        const avgY = (a.y + b.y) / 2;
        const newRadius = Math.sqrt(a.radius * a.radius + b.radius * b.radius);

        // Remove both dots
        const idxA = clusterDots.indexOf(a);
        if (idxA !== -1) clusterDots.splice(idxA, 1);
        const idxB = clusterDots.indexOf(b);
        if (idxB !== -1) clusterDots.splice(idxB, 1);

        // Create merged dot
        clusterDots.push({
          id: clusterNextId++,
          x: avgX,
          y: avgY,
          vx: 0,
          vy: 0,
          radius: newRadius,
          color: "#222222",
          isBlack: true,
          clusterId: null,
          hitsTaken: 0,
        });
      }

      function checkClusterLoseCondition() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const totalArea = width * height;

        // Calculate total area of colored dots
        let coloredArea = 0;
        let maxRadius = 0;
        for (const dot of clusterDots) {
          if (!dot.isBlack) {
            coloredArea += Math.PI * dot.radius * dot.radius;
            maxRadius = Math.max(maxRadius, dot.radius);
          }
        }

        const coverage = coloredArea / totalArea;

        // Show warning when coverage is high
        const warning = document.getElementById("clusterWarning");
        if (coverage > 0.3) {
          warning.classList.add("visible");
        } else {
          warning.classList.remove("visible");
        }

        // Lose if coverage too high or a dot is too big
        if (coverage > 0.5 || maxRadius > Math.min(width, height) * 0.3) {
          endClusterRound();
        }
      }

      function renderClusterDots() {
        const circles = clusterDotsGroup
          .selectAll("circle")
          .data(clusterDots, (d) => d.id);

        circles.exit().remove();

        const entered = circles
          .enter()
          .append("circle")
          .attr("r", (d) => d.radius)
          .attr("fill", (d) => d.color)
          .attr("stroke", (d) => (d.isBlack ? "#000" : darkenColor(d.color)))
          .attr("stroke-width", 2)
          .attr("cursor", (d) => (d.isBlack ? "grab" : "default"))
          .style("filter", (d) =>
            !d.isBlack && d.radius > 15
              ? "drop-shadow(0 0 8px " + d.color + ")"
              : "none",
          )
          .on("mousedown", function (event, d) {
            if (d.isBlack) {
              event.stopPropagation();
              clusterDragDotId = d.id;
              const [mx, my] = d3.pointer(event, svg.node());
              clusterDragStartPos = { x: mx, y: my };
              clusterDragOriginalPos = { x: d.x, y: d.y };
              svg.classed("dragging", true);
            }
          })
          .on("touchstart", function (event, d) {
            if (d.isBlack) {
              event.preventDefault();
              event.stopPropagation();
              clusterDragDotId = d.id;
              const touch = event.touches[0];
              const rect = svg.node().getBoundingClientRect();
              clusterDragStartPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top,
              };
              clusterDragOriginalPos = { x: d.x, y: d.y };
              svg.classed("dragging", true);
            }
          });

        entered
          .merge(circles)
          .attr("cx", (d) => d.x)
          .attr("cy", (d) => d.y)
          .attr("r", (d) => d.radius)
          .attr("fill", (d) => d.color)
          .attr("stroke", (d) => (d.isBlack ? "#000" : darkenColor(d.color)))
          .style("filter", (d) =>
            !d.isBlack && d.radius > 15
              ? "drop-shadow(0 0 8px " + d.color + ")"
              : "none",
          );

        // Show hit indicators on colored dots being attacked
        const hitIndicators = clusterDotsGroup
          .selectAll("text.hit-indicator")
          .data(
            clusterDots.filter((d) => !d.isBlack && d.hitsTaken > 0),
            (d) => d.id,
          );

        hitIndicators.exit().remove();

        hitIndicators
          .enter()
          .append("text")
          .attr("class", "hit-indicator")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("fill", "#fff")
          .attr("font-size", "12px")
          .attr("font-weight", "bold")
          .attr("pointer-events", "none")
          .merge(hitIndicators)
          .attr("x", (d) => d.x)
          .attr("y", (d) => d.y)
          .text((d) => d.hitsTaken);
      }

      function darkenColor(color) {
        // Simple color darkening for stroke
        const colors = {
          "#ff4444": "#cc0000",
          "#ffcc00": "#cc9900",
          "#4444ff": "#0000cc",
          "#44cc44": "#009900",
          "#222222": "#000000",
          "#ffffff": "#cccccc",
        };
        return colors[color] || color;
      }

      function clusterTick() {
        clusterTimeElapsed++;

        // Increase spawn rate over time
        if (clusterTimeElapsed % 10 === 0 && clusterSpawnInterval > 500) {
          clusterSpawnInterval = Math.max(500, clusterSpawnInterval - 100);
        }

        updateClusterHUD();
      }

      function formatClusterTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins + ":" + (secs < 10 ? "0" : "") + secs;
      }

      function updateClusterHUD() {
        const timerValue = document.getElementById("clusterTimerValue");
        const bestLabel = document.getElementById("clusterBestLabel");

        if (!timerValue) return;

        timerValue.textContent = formatClusterTime(clusterTimeElapsed);
        bestLabel.textContent = "Best: " + formatClusterTime(clusterBest);
      }

      // ========== RENDER ==========
      function render() {
        const circles = dotsGroup.selectAll("circle").data(dots, (d) => d.id);

        circles.exit().remove();

        const theme = themes[currentTheme];
        circles
          .enter()
          .append("circle")
          .attr("cx", (d) => d.x)
          .attr("cy", (d) => d.y)
          .attr("r", (d) => d.radius)
          .attr("fill", theme.dotFill)
          .attr("stroke", theme.dotStroke)
          .attr("stroke-width", STROKE_WIDTH)
          .on("mousedown", onDotMouseDown)
          .on("mouseup", onDotMouseUp)
          .on("mouseleave", onDotMouseLeave)
          .on("dblclick", onDotDoubleClick)
          .on("touchstart", onDotTouchStart)
          .on("touchend", onDotTouchEnd)
          .on("touchmove", onDotTouchMove);

        circles
          .attr("cx", (d) => d.x)
          .attr("cy", (d) => d.y)
          .attr("r", (d) => d.radius);
      }

      // ========== DOT CREATION ==========
      function createDot(x, y) {
        // Disable dot creation in game modes
        if (golfMode || pinballMode || clusterMode) return;

        const count = parseInt(
          document.getElementById("countSlider").value,
          10,
        );

        if (count === 1) {
          const placement = findPlacementPosition(x, y, DEFAULT_RADIUS);
          if (!wouldOverlap(placement.x, placement.y, DEFAULT_RADIUS)) {
            dots.push({
              id: nextId++,
              x: placement.x,
              y: placement.y,
              radius: DEFAULT_RADIUS,
            });
          }
        } else {
          createDotCluster(x, y, count);
        }
        render();
      }

      function createDotCluster(centerX, centerY, count) {
        const diameter = DEFAULT_RADIUS * 2;
        const centerPlacement = findPlacementPosition(
          centerX,
          centerY,
          DEFAULT_RADIUS,
        );
        if (
          wouldOverlap(centerPlacement.x, centerPlacement.y, DEFAULT_RADIUS)
        ) {
          return;
        }

        const centerDot = {
          id: nextId++,
          x: centerPlacement.x,
          y: centerPlacement.y,
          radius: DEFAULT_RADIUS,
        };
        dots.push(centerDot);

        if (count === 1) return;

        let placed = 1;
        let ring = 1;
        let angleOffset = Math.random() * Math.PI * 2;

        while (placed < count) {
          const dotsInRing = ring === 1 ? 6 : ring * 6;
          const angleStep = (Math.PI * 2) / dotsInRing;

          for (let i = 0; i < dotsInRing && placed < count; i++) {
            const angle = angleOffset + i * angleStep;
            const distance = diameter * ring;

            const testX = centerPlacement.x + Math.cos(angle) * distance;
            const testY = centerPlacement.y + Math.sin(angle) * distance;

            const snapped = snapToGrid(testX, testY);

            if (!wouldOverlap(snapped.x, snapped.y, DEFAULT_RADIUS)) {
              dots.push({
                id: nextId++,
                x: snapped.x,
                y: snapped.y,
                radius: DEFAULT_RADIUS,
              });
              placed++;
            }
          }
          ring++;
          if (ring > 5) break;
        }
      }

      // ========== GROW / SHRINK ==========
      function growDot(id) {
        const dot = dots.find((d) => d.id === id);
        if (!dot) return;

        const newRadius = Math.min(dot.radius * 2, MAX_RADIUS);
        const radiusIncrease = newRadius - dot.radius;

        if (!wouldOverlap(dot.x, dot.y, newRadius, id)) {
          dot.radius = newRadius;
          render();
          return;
        }

        // Find dots that would overlap and shift away
        const overlappingDots = dots.filter((other) => {
          if (other.id === id) return false;
          const dx = other.x - dot.x;
          const dy = other.y - dot.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < newRadius + other.radius;
        });

        if (overlappingDots.length === 0) return;

        let shiftX = 0,
          shiftY = 0;
        for (const other of overlappingDots) {
          const dx = dot.x - other.x;
          const dy = dot.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            shiftX += dx / dist;
            shiftY += dy / dist;
          }
        }

        const shiftMag = Math.sqrt(shiftX * shiftX + shiftY * shiftY);
        if (shiftMag === 0) return;
        shiftX /= shiftMag;
        shiftY /= shiftMag;

        const newX = dot.x + shiftX * radiusIncrease;
        const newY = dot.y + shiftY * radiusIncrease;

        if (!wouldOverlap(newX, newY, newRadius, id)) {
          dot.x = newX;
          dot.y = newY;
          dot.radius = newRadius;
          render();
        }
      }

      function shrinkDot(id) {
        const dot = dots.find((d) => d.id === id);
        if (!dot) return;

        const newRadius = dot.radius / 2;
        if (newRadius < MIN_RADIUS) {
          dots = dots.filter((d) => d.id !== id);
          dotVelocities.delete(id);
          noFrictionDots.delete(id);
          boostedDots.delete(id);
        } else {
          dot.radius = newRadius;
        }
        render();
      }

      // ========== HOLD TIMER ==========
      function clearHoldTimer() {
        if (holdTimer) {
          clearTimeout(holdTimer);
          holdTimer = null;
        }
        holdDotId = null;
      }

      // ========== DOT EVENT HANDLERS ==========
      function onDotMouseDown(event, d) {
        event.stopPropagation();
        holdDotId = d.id;

        const [mx, my] = d3.pointer(event, svg.node());
        dragStartPos = { x: mx, y: my };
        dragOriginalPos = { x: d.x, y: d.y };
        dragDotId = d.id;
        isDragging = false;

        // Initialize velocity for this dot if not already moving
        if (!dotVelocities.has(d.id)) {
          dotVelocities.set(d.id, { vx: 0, vy: 0 });
        }

        holdTimer = setTimeout(() => {
          if (holdDotId === d.id && !isDragging) {
            shrinkDot(d.id);
          }
          clearHoldTimer();
        }, HOLD_DURATION);
      }

      function onDotMouseUp(event, d) {
        event.stopPropagation();
        finalizeDrag();
        clearHoldTimer();
      }

      function onDotMouseLeave(event, d) {
        if (!isDragging) {
          clearHoldTimer();
        }
      }

      function onDotDoubleClick(event, d) {
        event.stopPropagation();
        event.preventDefault();
        clearHoldTimer();

        // If dot is moving, stop it
        if (dotVelocities.has(d.id)) {
          const vel = dotVelocities.get(d.id);
          const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
          if (speed > MIN_VELOCITY) {
            dotVelocities.delete(d.id);
            noFrictionDots.delete(d.id);
            const snapped = snapToGrid(d.x, d.y);
            if (!wouldOverlap(snapped.x, snapped.y, d.radius, d.id)) {
              d.x = snapped.x;
              d.y = snapped.y;
            }
            render();
            return;
          }
        }

        growDot(d.id);
      }

      // ========== TOUCH EVENT HANDLERS FOR DOTS ==========
      function onDotTouchStart(event, d) {
        event.preventDefault();
        event.stopPropagation();

        const touch = event.touches[0];
        const [tx, ty] = [touch.clientX, touch.clientY];

        // Check for double-tap
        const now = Date.now();
        if (
          lastTapTime &&
          now - lastTapTime < DOUBLE_TAP_THRESHOLD &&
          lastTapPos
        ) {
          const dist = Math.sqrt(
            (tx - lastTapPos.x) ** 2 + (ty - lastTapPos.y) ** 2,
          );
          if (dist < DOUBLE_TAP_DISTANCE) {
            // Double-tap detected
            lastTapTime = 0;
            lastTapPos = null;
            onDotDoubleClick(event, d);
            return;
          }
        }
        lastTapTime = now;
        lastTapPos = { x: tx, y: ty };

        // Start drag
        holdDotId = d.id;
        const rect = svg.node().getBoundingClientRect();
        dragStartPos = { x: tx - rect.left, y: ty - rect.top };
        dragOriginalPos = { x: d.x, y: d.y };
        dragDotId = d.id;
        isDragging = false;

        if (!dotVelocities.has(d.id)) {
          dotVelocities.set(d.id, { vx: 0, vy: 0 });
        }

        holdTimer = setTimeout(() => {
          if (holdDotId === d.id && !isDragging) {
            shrinkDot(d.id);
          }
          clearHoldTimer();
        }, HOLD_DURATION);
      }

      function onDotTouchMove(event, d) {
        if (dragDotId === null) return;
        event.preventDefault();

        const touch = event.touches[0];
        const rect = svg.node().getBoundingClientRect();
        const tx = touch.clientX - rect.left;
        const ty = touch.clientY - rect.top;

        const dx = tx - dragStartPos.x;
        const dy = ty - dragStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (!isDragging && distance > DRAG_THRESHOLD) {
          isDragging = true;
          clearHoldTimer();
          svg.classed("dragging", true);
          startPhysicsLoop();
        }

        if (isDragging) {
          dragTargetPos = {
            x: dragOriginalPos.x + dx,
            y: dragOriginalPos.y + dy,
          };
        }
      }

      function onDotTouchEnd(event, d) {
        event.preventDefault();
        finalizeDrag();
        clearHoldTimer();
      }

      // ========== DRAG HANDLING ==========
      svg.on("mousemove", function (event) {
        // Handle cluster black dot dragging
        if (clusterDragDotId !== null) {
          const [mx, my] = d3.pointer(event, svg.node());
          const dx = mx - clusterDragStartPos.x;
          const dy = my - clusterDragStartPos.y;
          const dot = clusterDots.find((d) => d.id === clusterDragDotId);
          if (dot) {
            const newX = clusterDragOriginalPos.x + dx;
            const newY = clusterDragOriginalPos.y + dy;

            // Track velocity based on position change
            if (clusterDragLastPos) {
              clusterDragVelocity.vx =
                (newX - clusterDragLastPos.x) * 0.5 +
                clusterDragVelocity.vx * 0.5;
              clusterDragVelocity.vy =
                (newY - clusterDragLastPos.y) * 0.5 +
                clusterDragVelocity.vy * 0.5;
            }
            clusterDragLastPos = { x: newX, y: newY };

            dot.x = newX;
            dot.y = newY;
            // Keep in bounds
            dot.x = Math.max(
              dot.radius,
              Math.min(window.innerWidth - dot.radius, dot.x),
            );
            dot.y = Math.max(
              dot.radius,
              Math.min(window.innerHeight - dot.radius, dot.y),
            );
          }
          return;
        }

        if (dragDotId === null) return;

        const [mx, my] = d3.pointer(event, svg.node());
        const dx = mx - dragStartPos.x;
        const dy = my - dragStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (!isDragging && distance > DRAG_THRESHOLD) {
          isDragging = true;
          clearHoldTimer();
          svg.classed("dragging", true);
          startPhysicsLoop();
        }

        if (isDragging) {
          dragTargetPos = {
            x: dragOriginalPos.x + dx,
            y: dragOriginalPos.y + dy,
          };
        }
      });

      svg.on("mouseup", function (event) {
        // Handle cluster black dot release
        if (clusterDragDotId !== null) {
          finalizeClusterDrag();
          return;
        }
        finalizeDrag();
      });

      // Touch handlers for cluster dragging
      svg.on("touchmove", function (event) {
        if (clusterDragDotId !== null) {
          event.preventDefault();
          const touch = event.touches[0];
          const rect = svg.node().getBoundingClientRect();
          const tx = touch.clientX - rect.left;
          const ty = touch.clientY - rect.top;
          const dx = tx - clusterDragStartPos.x;
          const dy = ty - clusterDragStartPos.y;
          const dot = clusterDots.find((d) => d.id === clusterDragDotId);
          if (dot) {
            const newX = clusterDragOriginalPos.x + dx;
            const newY = clusterDragOriginalPos.y + dy;

            // Track velocity
            if (clusterDragLastPos) {
              clusterDragVelocity.vx =
                (newX - clusterDragLastPos.x) * 0.5 +
                clusterDragVelocity.vx * 0.5;
              clusterDragVelocity.vy =
                (newY - clusterDragLastPos.y) * 0.5 +
                clusterDragVelocity.vy * 0.5;
            }
            clusterDragLastPos = { x: newX, y: newY };

            dot.x = newX;
            dot.y = newY;
            dot.x = Math.max(
              dot.radius,
              Math.min(window.innerWidth - dot.radius, dot.x),
            );
            dot.y = Math.max(
              dot.radius,
              Math.min(window.innerHeight - dot.radius, dot.y),
            );
          }
        }
      });

      svg.on("touchend", function (event) {
        if (clusterDragDotId !== null) {
          event.preventDefault();
          finalizeClusterDrag();
        }
      });

      function finalizeDrag() {
        if (isDragging && dragDotId !== null) {
          // On release, just let physics continue - don't switch modes
          // The dot already has velocity from steering
          const vel = dotVelocities.get(dragDotId);
          if (vel) {
            // Apply boost multiplier to throw velocity if boost is active
            if (isBoostKeyHeld) {
              vel.vx *= BOOST_MULTIPLIER;
              vel.vy *= BOOST_MULTIPLIER;
              boostedDots.add(dragDotId);
            }

            // Chain Reaction: auto-boost and start round on next throw
            if (chainWaitingForThrow) {
              if (!isBoostKeyHeld) {
                vel.vx *= BOOST_MULTIPLIER;
                vel.vy *= BOOST_MULTIPLIER;
                boostedDots.add(dragDotId);
              }
              chainWaitingForThrow = false;
              startChainReactionRound(dragDotId);
              document.getElementById("chainStartBtn").textContent =
                "Start Chain";
            }

            // Golf: count strokes when ball is thrown
            if (
              golfMode &&
              golfBallId !== null &&
              dragDotId === golfBallId &&
              !golfHoleComplete
            ) {
              golfStrokes++;
              updateGolfHUD();
            }

            // Pinball: activate round on first throw
            if (
              pinballMode &&
              pinballBallId !== null &&
              dragDotId === pinballBallId &&
              !pinballRoundActive
            ) {
              pinballRoundActive = true;
              document.getElementById("pinballStartBtn").style.display = "none";
            }

            const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
            if (speed < MIN_VELOCITY) {
              // If barely moving, snap to grid and stop
              const dot = dots.find((d) => d.id === dragDotId);
              if (dot) {
                const snapped = snapToGrid(dot.x, dot.y);
                if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                  dot.x = snapped.x;
                  dot.y = snapped.y;
                }
              }
              dotVelocities.delete(dragDotId);
              noFrictionDots.delete(dragDotId);
              boostedDots.delete(dragDotId);
              render();
            } else if (isNoFrictionKeyHeld) {
              // Mark this dot as no-friction (perpetual motion)
              noFrictionDots.add(dragDotId);
            }
          }
        } else if (dragDotId !== null) {
          // Wasn't dragging, remove velocity if stationary
          const vel = dotVelocities.get(dragDotId);
          if (
            vel &&
            Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy) < MIN_VELOCITY
          ) {
            dotVelocities.delete(dragDotId);
          }
        }

        isDragging = false;
        dragDotId = null;
        dragStartPos = null;
        dragOriginalPos = null;
        dragTargetPos = null;
        velocityHistory = [];
        svg.classed("dragging", false);
      }

      function finalizeClusterDrag() {
        if (clusterDragDotId !== null) {
          const draggedDot = clusterDots.find((d) => d.id === clusterDragDotId);
          if (draggedDot && draggedDot.isBlack) {
            // Apply throw velocity (with boost)
            const throwMultiplier = 8;
            draggedDot.vx = clusterDragVelocity.vx * throwMultiplier;
            draggedDot.vy = clusterDragVelocity.vy * throwMultiplier;

            // Check if we should merge with another black dot (if barely moving)
            const speed = Math.sqrt(
              draggedDot.vx * draggedDot.vx + draggedDot.vy * draggedDot.vy,
            );
            if (speed < 1) {
              for (const other of clusterDots) {
                if (other.id === clusterDragDotId || !other.isBlack) continue;

                const dx = other.x - draggedDot.x;
                const dy = other.y - draggedDot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = draggedDot.radius + other.radius;

                if (dist < minDist * 0.8) {
                  // Merge the two black dots
                  mergeBlackDots(draggedDot, other);
                  break;
                }
              }
            }
          }
        }

        clusterDragDotId = null;
        clusterDragStartPos = null;
        clusterDragOriginalPos = null;
        clusterDragLastPos = null;
        clusterDragVelocity = { vx: 0, vy: 0 };
        svg.classed("dragging", false);
      }

      // ========== UNIFIED PHYSICS LOOP ==========
      function physicsLoop() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Step 1: Apply drag steering (if dragging)
        if (isDragging && dragDotId !== null && dragTargetPos) {
          const dragDot = dots.find((d) => d.id === dragDotId);
          if (dragDot) {
            let vel = dotVelocities.get(dragDotId);
            if (!vel) {
              vel = { vx: 0, vy: 0 };
              dotVelocities.set(dragDotId, vel);
            }

            // Weight-based responsiveness (boosted when A key is held)
            const weight = mass(dragDot);
            const baseResponsiveness = Math.min(1, 0.3 / Math.sqrt(weight));
            const responsiveness = isBoostKeyHeld
              ? Math.min(1, baseResponsiveness * BOOST_MULTIPLIER)
              : baseResponsiveness;

            // Steering: compute desired velocity toward target
            const toTargetX = dragTargetPos.x - dragDot.x;
            const toTargetY = dragTargetPos.y - dragDot.y;

            // The velocity IS the movement toward target (weighted)
            vel.vx = toTargetX * responsiveness;
            vel.vy = toTargetY * responsiveness;
          }
        }

        // Step 2: Apply velocities to positions (only dragged dot if frozen)
        for (const [dotId, vel] of dotVelocities) {
          if (isFrozen && dotId !== dragDotId) continue;

          const dot = dots.find((d) => d.id === dotId);
          if (!dot) {
            dotVelocities.delete(dotId);
            continue;
          }

          dot.x += vel.vx;
          dot.y += vel.vy;
        }

        // Step 3: Boundary collisions (only for dragged dot if frozen)
        for (const [dotId, vel] of dotVelocities) {
          if (isFrozen && dotId !== dragDotId) continue;

          const dot = dots.find((d) => d.id === dotId);
          if (!dot) continue;

          if (dot.x - dot.radius < 0) {
            dot.x = dot.radius;
            if (!isFrozen) vel.vx *= -0.7;
          } else if (dot.x + dot.radius > width) {
            dot.x = width - dot.radius;
            if (!isFrozen) vel.vx *= -0.7;
          }

          if (dot.y - dot.radius < 0) {
            dot.y = dot.radius;
            if (!isFrozen) vel.vy *= -0.7;
          } else if (dot.y + dot.radius > height) {
            dot.y = height - dot.radius;
            if (!isFrozen) vel.vy *= -0.7;
          }
        }

        // Step 4: Collision resolution
        if (isFrozen) {
          // In freeze mode, only handle collisions for the dragged dot
          // Other dots act as immovable obstacles
          if (isDragging && dragDotId !== null) {
            const dragDot = dots.find((d) => d.id === dragDotId);
            if (dragDot) {
              for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {
                for (const otherDot of dots) {
                  if (otherDot.id === dragDotId) continue;

                  const dx = otherDot.x - dragDot.x;
                  const dy = otherDot.y - dragDot.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  const minDist = dragDot.radius + otherDot.radius;

                  if (dist < minDist && dist > 0) {
                    // Push dragged dot back (other dot is immovable)
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const overlap = minDist - dist;

                    dragDot.x -= nx * overlap;
                    dragDot.y -= ny * overlap;

                    // Also zero out velocity in that direction
                    const vel = dotVelocities.get(dragDotId);
                    if (vel) {
                      const velDotN = vel.vx * nx + vel.vy * ny;
                      if (velDotN > 0) {
                        vel.vx -= velDotN * nx;
                        vel.vy -= velDotN * ny;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          // Normal physics: full collision resolution
          for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {
            processedCollisions.clear();

            for (let i = 0; i < dots.length; i++) {
              const dotA = dots[i];
              const velA = dotVelocities.get(dotA.id) || { vx: 0, vy: 0 };

              for (let j = i + 1; j < dots.length; j++) {
                const dotB = dots[j];

                // Skip if neither dot is moving (optimization)
                const velB = dotVelocities.get(dotB.id) || { vx: 0, vy: 0 };
                const aMoving = dotVelocities.has(dotA.id);
                const bMoving = dotVelocities.has(dotB.id);
                if (!aMoving && !bMoving) continue;

                const collisionKey = dotA.id + "-" + dotB.id;
                if (processedCollisions.has(collisionKey)) continue;
                processedCollisions.add(collisionKey);

                // Ensure both have velocity entries for collision resolution
                if (!dotVelocities.has(dotA.id)) {
                  dotVelocities.set(dotA.id, { vx: 0, vy: 0 });
                }
                if (!dotVelocities.has(dotB.id)) {
                  dotVelocities.set(dotB.id, { vx: 0, vy: 0 });
                }

                const velARef = dotVelocities.get(dotA.id);
                const velBRef = dotVelocities.get(dotB.id);

                resolveCollision(dotA, dotB, velARef, velBRef);
              }
            }
          }
        }

        // Step 4.5: Pinball bumper collisions
        if (pinballMode && pinballRoundActive && pinballBallId !== null) {
          const ball = dots.find((d) => d.id === pinballBallId);
          if (ball) {
            const vel = dotVelocities.get(pinballBallId);
            if (vel) {
              for (const bumper of pinballBumpers) {
                const dx = ball.x - bumper.x;
                const dy = ball.y - bumper.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = ball.radius + bumper.radius;

                if (dist < minDist && dist > 0) {
                  // Bounce off bumper
                  const nx = dx / dist;
                  const ny = dy / dist;

                  // Push ball out
                  const overlap = minDist - dist;
                  ball.x += nx * overlap;
                  ball.y += ny * overlap;

                  // Reflect velocity with boost
                  const dot = vel.vx * nx + vel.vy * ny;
                  if (dot < 0) {
                    // Moving toward bumper
                    vel.vx -= 2 * dot * nx;
                    vel.vy -= 2 * dot * ny;

                    // Apply boost
                    vel.vx *= 1.3;
                    vel.vy *= 1.3;

                    // Score!
                    pinballScore += bumper.points;
                    updatePinballHUD();
                  }
                }
              }
            }
          }
        }

        // Step 5: Apply friction (skip if frozen, or for dragged/perpetual dots)
        if (!isFrozen) {
          for (const [dotId, vel] of dotVelocities) {
            if (dotId === dragDotId) continue; // Don't apply friction while dragging
            if (noFrictionDots.has(dotId)) continue; // Perpetual motion dots

            const dot = dots.find((d) => d.id === dotId);
            if (!dot) continue;

            // Mass-based friction: heavier dots have more inertia
            const m = mass(dot);
            const baseFriction = getFriction();
            const friction = 1 - (1 - baseFriction) / Math.sqrt(m);
            vel.vx *= friction;
            vel.vy *= friction;

            // Stop if velocity is very low
            const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
            if (speed < MIN_VELOCITY) {
              // Snap to grid
              const snapped = snapToGrid(dot.x, dot.y);
              if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                dot.x = snapped.x;
                dot.y = snapped.y;
              }
              dotVelocities.delete(dotId);

              // Golf: check if ball stopped in target
              if (golfMode && dotId === golfBallId && !golfHoleComplete) {
                checkGolfWin();
              }
            }
          }
        }

        // Step 6: Cluster mode physics
        if (clusterMode && clusterRoundActive) {
          updateClusterPhysics();
          renderClusterDots();
        }

        render();

        // Continue loop if any dots are moving OR dragging is active OR cluster mode active
        if (
          dotVelocities.size > 0 ||
          isDragging ||
          (clusterMode && clusterRoundActive)
        ) {
          physicsAnimationId = requestAnimationFrame(physicsLoop);
        } else {
          physicsAnimationId = null;

          // Chain Reaction: end round when all motion stops
          if (chainReactionMode && chainReactionActive) {
            endChainReactionRound();
          }

          // Pinball: end round when all motion stops
          if (pinballMode && pinballRoundActive) {
            endPinballRound();
          }
        }
      }

      function startPhysicsLoop() {
        if (!physicsAnimationId) {
          physicsAnimationId = requestAnimationFrame(physicsLoop);
        }
      }

      // ========== BACKGROUND HANDLERS ==========
      background.on("dblclick", function (event) {
        const [x, y] = d3.pointer(event);
        createDot(x, y);
      });

      // Touch support for background (double-tap to create)
      background.on("touchstart", function (event) {
        event.preventDefault();
        const touch = event.touches[0];
        const rect = svg.node().getBoundingClientRect();
        const tx = touch.clientX - rect.left;
        const ty = touch.clientY - rect.top;

        const now = Date.now();
        if (
          lastTapTime &&
          now - lastTapTime < DOUBLE_TAP_THRESHOLD &&
          lastTapPos
        ) {
          const dist = Math.sqrt(
            (touch.clientX - lastTapPos.x) ** 2 +
              (touch.clientY - lastTapPos.y) ** 2,
          );
          if (dist < DOUBLE_TAP_DISTANCE) {
            // Double-tap detected - create dot
            lastTapTime = 0;
            lastTapPos = null;
            createDot(tx, ty);
            return;
          }
        }
        lastTapTime = now;
        lastTapPos = { x: touch.clientX, y: touch.clientY };
      });

      // ========== UI CONTROLS ==========

      // Controls panel toggle
      const controlsToggle = document.getElementById("controlsToggle");
      const controlsPanel = document.getElementById("controlsPanel");
      controlsToggle.addEventListener("click", () => {
        controlsPanel.classList.toggle("open");
      });

      // Dot count slider
      const countSlider = document.getElementById("countSlider");
      const countValue = document.getElementById("countValue");
      countSlider.addEventListener("input", () => {
        countValue.textContent = countSlider.value;
      });

      // Modifier toggles (work alongside keyboard)
      const boostToggle = document.getElementById("boostToggle");
      const perpetualToggle = document.getElementById("perpetualToggle");

      boostToggle.addEventListener("click", () => {
        isBoostKeyHeld = !isBoostKeyHeld;
        boostToggle.classList.toggle("active", isBoostKeyHeld);
        boostIndicator.classList.toggle("active", isBoostKeyHeld);
      });

      perpetualToggle.addEventListener("click", () => {
        isNoFrictionKeyHeld = !isNoFrictionKeyHeld;
        perpetualToggle.classList.toggle("active", isNoFrictionKeyHeld);
        perpetualIndicator.classList.toggle("active", isNoFrictionKeyHeld);
      });

      // Physics sliders
      const frictionSlider = document.getElementById("frictionSlider");
      const frictionValue = document.getElementById("frictionValue");
      frictionSlider.addEventListener("input", () => {
        frictionValue.textContent = frictionSlider.value;
      });

      const bounceSlider = document.getElementById("bounceSlider");
      const bounceValue = document.getElementById("bounceValue");
      bounceSlider.addEventListener("input", () => {
        bounceValue.textContent = bounceSlider.value;
      });

      // Helper to get current physics values
      function getFriction() {
        return parseFloat(frictionSlider.value) / 100;
      }

      function getRestitution() {
        return parseFloat(bounceSlider.value) / 100;
      }

      // Freeze toggle
      const freezeToggle = document.getElementById("freezeToggle");
      const freezeIndicator = document.getElementById("freezeIndicator");
      freezeToggle.addEventListener("change", () => {
        isFrozen = freezeToggle.checked;
        freezeIndicator.classList.toggle("active", isFrozen);
        if (isFrozen) {
          // Stop all dots when freezing
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();
        }
      });

      // Chain Reaction controls
      const chainReactionToggle = document.getElementById(
        "chainReactionToggle",
      );
      const chainThresholdRow = document.getElementById("chainThresholdRow");
      const chainThresholdSlider = document.getElementById(
        "chainThresholdSlider",
      );
      const chainThresholdValue = document.getElementById(
        "chainThresholdValue",
      );
      const chainStartBtn = document.getElementById("chainStartBtn");
      const chainResetBtn = document.getElementById("chainResetBtn");
      const chainScoreHUD = document.getElementById("chainScoreHUD");

      chainReactionToggle.addEventListener("change", () => {
        chainReactionMode = chainReactionToggle.checked;
        chainScoreHUD.classList.toggle("active", chainReactionMode);
        chainThresholdRow.style.display = chainReactionMode ? "flex" : "none";
        chainStartBtn.style.display = chainReactionMode ? "block" : "none";
        chainResetBtn.style.display = chainReactionMode ? "block" : "none";

        if (chainReactionMode) {
          // Disable other game modes
          const golfToggleEl = document.getElementById("golfToggle");
          if (golfToggleEl.checked) {
            golfToggleEl.checked = false;
            golfToggleEl.dispatchEvent(new Event("change"));
          }
          const pinballToggleEl = document.getElementById("pinballToggle");
          if (pinballToggleEl.checked) {
            pinballToggleEl.checked = false;
            pinballToggleEl.dispatchEvent(new Event("change"));
          }
          const clusterToggleEl = document.getElementById("clusterToggle");
          if (clusterToggleEl.checked) {
            clusterToggleEl.checked = false;
            clusterToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          chainReactionActive = false;
          chainReactionScore = 0;
          chainReactionStartDotId = null;
          chainWaitingForThrow = false;
        }
      });

      chainThresholdSlider.addEventListener("input", () => {
        chainThresholdValue.textContent = chainThresholdSlider.value;
      });

      chainStartBtn.addEventListener("click", () => {
        if (chainReactionActive) return;
        chainWaitingForThrow = true;
        chainStartBtn.textContent = "Throw a dot!";
      });

      chainResetBtn.addEventListener("click", () => {
        chainWaitingForThrow = false;
        chainStartBtn.textContent = "Start Chain";
        resetChainReaction();
      });

      // Golf mode
      const golfToggle = document.getElementById("golfToggle");
      const golfStartBtn = document.getElementById("golfStartBtn");
      const golfNextBtn = document.getElementById("golfNextBtn");
      const golfHUD = document.getElementById("golfHUD");

      golfToggle.addEventListener("change", () => {
        golfMode = golfToggle.checked;
        golfHUD.classList.toggle("active", golfMode);
        golfStartBtn.style.display = golfMode ? "block" : "none";

        if (golfMode) {
          // Disable other game modes
          if (chainReactionToggle.checked) {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          }
          const pinballToggleEl = document.getElementById("pinballToggle");
          if (pinballToggleEl.checked) {
            pinballToggleEl.checked = false;
            pinballToggleEl.dispatchEvent(new Event("change"));
          }
          const clusterToggleEl = document.getElementById("clusterToggle");
          if (clusterToggleEl.checked) {
            clusterToggleEl.checked = false;
            clusterToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          resetGolf();
          golfNextBtn.style.display = "none";
        }
      });

      golfStartBtn.addEventListener("click", () => {
        if (!golfHoleComplete && golfBallId !== null) return; // Already playing
        startGolfHole();
        golfStartBtn.style.display = "none";
      });

      golfNextBtn.addEventListener("click", () => {
        nextGolfHole();
        golfNextBtn.style.display = "none";
      });

      // Pinball mode
      const pinballToggle = document.getElementById("pinballToggle");
      const pinballStartBtn = document.getElementById("pinballStartBtn");
      const pinballHUD = document.getElementById("pinballHUD");

      pinballToggle.addEventListener("change", () => {
        pinballMode = pinballToggle.checked;
        pinballHUD.classList.toggle("active", pinballMode);
        pinballStartBtn.style.display = pinballMode ? "block" : "none";

        if (pinballMode) {
          // Disable other game modes
          if (chainReactionToggle.checked) {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          }
          if (golfToggle.checked) {
            golfToggle.checked = false;
            golfToggle.dispatchEvent(new Event("change"));
          }
          const clusterToggleEl = document.getElementById("clusterToggle");
          if (clusterToggleEl.checked) {
            clusterToggleEl.checked = false;
            clusterToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          resetPinball();
        }
      });

      pinballStartBtn.addEventListener("click", () => {
        startPinballRound();
      });

      // Cluster mode
      const clusterToggle = document.getElementById("clusterToggle");
      const clusterStartBtn = document.getElementById("clusterStartBtn");
      const clusterHUD = document.getElementById("clusterHUD");

      clusterToggle.addEventListener("change", () => {
        clusterMode = clusterToggle.checked;
        clusterHUD.classList.toggle("active", clusterMode);
        clusterStartBtn.style.display = clusterMode ? "block" : "none";

        if (clusterMode) {
          // Disable other game modes
          if (chainReactionToggle.checked) {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          }
          if (golfToggle.checked) {
            golfToggle.checked = false;
            golfToggle.dispatchEvent(new Event("change"));
          }
          const pinballToggleEl = document.getElementById("pinballToggle");
          if (pinballToggleEl.checked) {
            pinballToggleEl.checked = false;
            pinballToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          resetCluster();
        }
      });

      clusterStartBtn.addEventListener("click", () => {
        startClusterRound();
      });

      // Grid toggle
      const gridToggle = document.getElementById("gridToggle");
      gridToggle.addEventListener("change", () => {
        gridGroup.style("display", gridToggle.checked ? "block" : "none");
      });

      // Theme selector
      const themeSelect = document.getElementById("themeSelect");

      function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) return;

        currentTheme = themeName;

        // Update background
        document.body.style.background = theme.background;
        background.attr("fill", theme.background);

        // Update existing dots
        dotsGroup
          .selectAll("circle")
          .attr("fill", theme.dotFill)
          .attr("stroke", theme.dotStroke);

        // Update UI elements that need theme colors
        document.querySelectorAll("#modifiers .modifier").forEach((el) => {
          el.style.background =
            theme.ui === "#ffffff"
              ? "rgba(255,255,255,0.9)"
              : "rgba(0,0,0,0.8)";
          el.style.color = theme.ui === "#ffffff" ? "#000" : "#fff";
        });

        freezeIndicator.style.background =
          theme.ui === "#ffffff" ? "rgba(255,255,255,0.9)" : "rgba(0,0,0,0.8)";
        freezeIndicator.style.color = theme.ui === "#ffffff" ? "#000" : "#fff";

        // Update help button
        const helpBtn = document.getElementById("helpBtn");
        helpBtn.style.borderColor = theme.ui;
        helpBtn.style.color = theme.ui;
      }

      themeSelect.addEventListener("change", () => {
        applyTheme(themeSelect.value);
      });

      // Stop all dots
      document.getElementById("stopAllBtn").addEventListener("click", () => {
        for (const [dotId, vel] of dotVelocities) {
          const dot = dots.find((d) => d.id === dotId);
          if (dot) {
            const snapped = snapToGrid(dot.x, dot.y);
            if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
              dot.x = snapped.x;
              dot.y = snapped.y;
            }
          }
        }
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        render();
      });

      // Save state
      document.getElementById("saveBtn").addEventListener("click", () => {
        const state = {
          dots: dots.map((d) => ({
            id: d.id,
            x: d.x,
            y: d.y,
            radius: d.radius,
          })),
          nextId: nextId,
          theme: currentTheme,
          settings: {
            dotsPerClick: countSlider.value,
            friction: frictionSlider.value,
            bounciness: bounceSlider.value,
            showGrid: gridToggle.checked,
          },
        };
        localStorage.setItem("dotsAppState", JSON.stringify(state));

        // Visual feedback
        const btn = document.getElementById("saveBtn");
        const originalText = btn.textContent;
        btn.textContent = "Saved!";
        setTimeout(() => {
          btn.textContent = originalText;
        }, 1000);
      });

      // Load state
      document.getElementById("loadBtn").addEventListener("click", () => {
        const saved = localStorage.getItem("dotsAppState");
        if (!saved) {
          const btn = document.getElementById("loadBtn");
          const originalText = btn.textContent;
          btn.textContent = "No save found";
          setTimeout(() => {
            btn.textContent = originalText;
          }, 1000);
          return;
        }

        try {
          const state = JSON.parse(saved);

          // Stop all current motion
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();

          // Restore dots
          dots = state.dots || [];
          nextId =
            state.nextId ||
            (dots.length > 0 ? Math.max(...dots.map((d) => d.id)) + 1 : 1);

          // Restore theme
          if (state.theme && themes[state.theme]) {
            themeSelect.value = state.theme;
            applyTheme(state.theme);
          }

          // Restore settings
          if (state.settings) {
            if (state.settings.dotsPerClick) {
              countSlider.value = state.settings.dotsPerClick;
              countValue.textContent = state.settings.dotsPerClick;
            }
            if (state.settings.friction) {
              frictionSlider.value = state.settings.friction;
              frictionValue.textContent = state.settings.friction;
            }
            if (state.settings.bounciness) {
              bounceSlider.value = state.settings.bounciness;
              bounceValue.textContent = state.settings.bounciness;
            }
            if (state.settings.showGrid !== undefined) {
              gridToggle.checked = state.settings.showGrid;
              gridGroup.style(
                "display",
                state.settings.showGrid ? "block" : "none",
              );
            }
          }

          render();

          // Visual feedback
          const btn = document.getElementById("loadBtn");
          const originalText = btn.textContent;
          btn.textContent = "Loaded!";
          setTimeout(() => {
            btn.textContent = originalText;
          }, 1000);
        } catch (e) {
          console.error("Failed to load state:", e);
        }
      });

      // Clear all
      document.getElementById("clearBtn").addEventListener("click", () => {
        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        render();
      });

      // ========== KEYBOARD CONTROLS ==========
      const boostIndicator = document.getElementById("boostIndicator");
      const perpetualIndicator = document.getElementById("perpetualIndicator");
      const helpModal = document.getElementById("helpModal");

      window.addEventListener("keydown", (e) => {
        if (e.key === "a" || e.key === "A") {
          isBoostKeyHeld = true;
          boostIndicator.classList.add("active");
          document.getElementById("boostToggle").classList.add("active");
        }
        if (e.key === "c" || e.key === "C") {
          isNoFrictionKeyHeld = true;
          perpetualIndicator.classList.add("active");
          document.getElementById("perpetualToggle").classList.add("active");
        }
        if (e.key === "f" || e.key === "F") {
          isFrozen = !isFrozen;
          freezeToggle.checked = isFrozen;
          freezeIndicator.classList.toggle("active", isFrozen);
          if (isFrozen) {
            dotVelocities.clear();
            noFrictionDots.clear();
            boostedDots.clear();
          }
        }
        if (e.key === "s" || e.key === "S") {
          // Stop all dots
          for (const [dotId, vel] of dotVelocities) {
            const dot = dots.find((d) => d.id === dotId);
            if (dot) {
              const snapped = snapToGrid(dot.x, dot.y);
              if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                dot.x = snapped.x;
                dot.y = snapped.y;
              }
            }
          }
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();
          render();
        }
        if (e.key === "?") {
          helpModal.classList.toggle("visible");
        }
        if (e.key === "Escape") {
          helpModal.classList.remove("visible");
          controlsPanel.classList.remove("open");
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "a" || e.key === "A") {
          isBoostKeyHeld = false;
          boostIndicator.classList.remove("active");
          document.getElementById("boostToggle").classList.remove("active");
        }
        if (e.key === "c" || e.key === "C") {
          isNoFrictionKeyHeld = false;
          perpetualIndicator.classList.remove("active");
          document.getElementById("perpetualToggle").classList.remove("active");
        }
      });

      // Help modal controls
      document.getElementById("helpBtn").addEventListener("click", () => {
        helpModal.classList.toggle("visible");
      });

      document.getElementById("closeHelp").addEventListener("click", () => {
        helpModal.classList.remove("visible");
      });

      helpModal.addEventListener("click", (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove("visible");
        }
      });

      // Initial render
      render();
    </script>
  </body>
</html>
