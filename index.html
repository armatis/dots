<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dots</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=JetBrains+Mono:wght@400;600&family=Oswald:wght@400;500;600;700&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #0a3d62;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
      }

      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        cursor: pointer;
        touch-action: none;
      }

      #gameCanvas.dragging {
        cursor: grabbing;
      }

      #gameCanvas.hovering-dot {
        cursor: grab;
      }

      #gameCanvas.dragging.hovering-dot {
        cursor: grabbing;
      }

      /* ========== CONTROLS PANEL - Observatory Theme ========== */
      :root {
        --panel-bg: rgba(8, 20, 32, 0.92);
        --panel-border: rgba(130, 204, 221, 0.15);
        --panel-glow: rgba(130, 204, 221, 0.08);
        --accent: #82ccdd;
        --accent-dim: rgba(130, 204, 221, 0.6);
        --accent-glow: rgba(130, 204, 221, 0.4);
        --text-primary: rgba(255, 255, 255, 0.95);
        --text-secondary: rgba(255, 255, 255, 0.5);
        --text-label: rgba(130, 204, 221, 0.7);
        --divider: rgba(130, 204, 221, 0.1);
        --danger: #ff6b6b;
        --danger-glow: rgba(255, 107, 107, 0.3);
      }

      #controls {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
        font-family: 'Outfit', system-ui, sans-serif;
        font-size: 13px;
        font-weight: 400;
      }

      #controlsToggle {
        width: 44px;
        height: 44px;
        background: var(--panel-bg);
        color: var(--accent);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: auto;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow:
          0 4px 24px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.05),
          0 0 0 1px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      #controlsToggle:hover {
        background: rgba(12, 28, 44, 0.95);
        border-color: var(--accent-dim);
        box-shadow:
          0 4px 24px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.08),
          0 0 20px var(--panel-glow),
          0 0 0 1px rgba(0, 0, 0, 0.3);
        transform: scale(1.05);
      }

      #controlsToggle:active {
        transform: scale(0.98);
      }

      #controlsPanel {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        padding: 0;
        margin-top: 12px;
        max-height: 0;
        overflow: hidden;
        transition:
          max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
          padding 0.4s cubic-bezier(0.4, 0, 0.2, 1),
          opacity 0.3s ease;
        box-shadow:
          0 8px 40px rgba(0, 0, 0, 0.5),
          0 0 80px var(--panel-glow),
          inset 0 1px 0 rgba(255, 255, 255, 0.05),
          0 0 0 1px rgba(0, 0, 0, 0.4);
        width: 280px;
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        opacity: 0;
      }

      #controlsPanel.open {
        max-height: calc(100vh - 100px);
        overflow-y: auto;
        padding: 20px;
        opacity: 1;
      }

      /* Hide scrollbar but keep scroll functionality */
      #controlsPanel {
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
      }
      #controlsPanel::-webkit-scrollbar {
        display: none; /* Chrome/Safari */
      }

      .control-section {
        margin-bottom: 20px;
        padding-bottom: 20px;
        border-bottom: 1px solid var(--divider);
        opacity: 0;
        transform: translateY(8px);
        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #controlsPanel.open .control-section {
        opacity: 1;
        transform: translateY(0);
      }

      /* Staggered animation delays */
      #controlsPanel.open .control-section:nth-child(1) { transition-delay: 0.05s; }
      #controlsPanel.open .control-section:nth-child(2) { transition-delay: 0.1s; }
      #controlsPanel.open .control-section:nth-child(3) { transition-delay: 0.15s; }
      #controlsPanel.open .control-section:nth-child(4) { transition-delay: 0.2s; }
      #controlsPanel.open .control-section:nth-child(5) { transition-delay: 0.25s; }
      #controlsPanel.open .control-section:nth-child(6) { transition-delay: 0.3s; }
      #controlsPanel.open .control-section:nth-child(7) { transition-delay: 0.35s; }

      .control-section:last-child {
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
      }

      .control-section h3 {
        margin: 0 0 14px 0;
        font-family: 'JetBrains Mono', monospace;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-label);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-section h3::before {
        content: '';
        width: 3px;
        height: 3px;
        background: var(--accent);
        border-radius: 50%;
        box-shadow: 0 0 6px var(--accent);
      }

      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        gap: 12px;
      }

      .control-row:last-child {
        margin-bottom: 0;
      }

      .control-row label {
        color: var(--text-primary);
        font-size: 13px;
        font-weight: 400;
        letter-spacing: 0.2px;
      }

      /* Custom Range Slider */
      .control-row input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 90px;
        height: 4px;
        background: var(--divider);
        border-radius: 2px;
        cursor: pointer;
        outline: none;
      }

      .control-row input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 0 10px var(--accent-glow), 0 2px 4px rgba(0,0,0,0.3);
        transition: all 0.2s ease;
      }

      .control-row input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.15);
        box-shadow: 0 0 16px var(--accent-glow), 0 2px 6px rgba(0,0,0,0.4);
      }

      .control-row input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: var(--accent);
        border: none;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 0 10px var(--accent-glow), 0 2px 4px rgba(0,0,0,0.3);
      }

      .control-row .value {
        min-width: 32px;
        text-align: right;
        font-family: 'JetBrains Mono', monospace;
        font-weight: 600;
        font-size: 12px;
        color: var(--accent);
        text-shadow: 0 0 8px var(--accent-glow);
      }

      /* Custom Toggle Switch */
      .control-row input[type="checkbox"] {
        -webkit-appearance: none;
        appearance: none;
        width: 40px;
        height: 22px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 11px;
        cursor: pointer;
        position: relative;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .control-row input[type="checkbox"]::after {
        content: '';
        position: absolute;
        top: 2px;
        left: 2px;
        width: 16px;
        height: 16px;
        background: var(--text-secondary);
        border-radius: 50%;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .control-row input[type="checkbox"]:checked {
        background: rgba(130, 204, 221, 0.2);
        border-color: var(--accent-dim);
      }

      .control-row input[type="checkbox"]:checked::after {
        transform: translateX(18px);
        background: var(--accent);
        box-shadow: 0 0 10px var(--accent-glow);
      }

      .control-row input[type="checkbox"]:hover {
        border-color: var(--accent-dim);
      }

      /* Modifier Toggle Buttons */
      .toggle-btn {
        padding: 8px 14px;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text-secondary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        font-family: 'Outfit', sans-serif;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .toggle-btn:hover {
        background: rgba(130, 204, 221, 0.1);
        border-color: var(--accent-dim);
        color: var(--text-primary);
      }

      .toggle-btn.active {
        background: rgba(130, 204, 221, 0.2);
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 0 16px var(--panel-glow), inset 0 0 12px var(--panel-glow);
      }

      .modifier-toggles {
        display: flex;
        gap: 10px;
      }

      .kbd-hint {
        font-family: 'JetBrains Mono', monospace;
        font-size: 9px;
        color: var(--text-secondary);
        margin-left: 4px;
        opacity: 0.7;
      }

      /* Paint Palette */
      .paint-palette {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }

      .paint-swatch {
        width: 28px;
        height: 28px;
        border-radius: 6px;
        border: 2px solid transparent;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      .paint-swatch:hover {
        transform: scale(1.15);
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
      }

      .paint-swatch.selected {
        border-color: var(--accent);
        box-shadow: 0 0 16px var(--accent-glow), inset 0 0 8px rgba(0, 0, 0, 0.3);
        transform: scale(1.1);
      }

      .paint-swatch.selected::after {
        content: '';
        position: absolute;
        top: -4px;
        right: -4px;
        width: 10px;
        height: 10px;
        background: var(--accent);
        border-radius: 50%;
        box-shadow: 0 0 8px var(--accent);
      }

      .paint-swatch.reset {
        background: linear-gradient(135deg, #666 25%, #999 25%, #999 50%, #666 50%, #666 75%, #999 75%);
        background-size: 8px 8px;
      }

      .paint-mode-toggle {
        width: 100%;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text-secondary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        font-family: 'Outfit', sans-serif;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .paint-mode-toggle:hover {
        background: rgba(130, 204, 221, 0.1);
        border-color: var(--accent-dim);
        color: var(--text-primary);
      }

      .paint-mode-toggle.active {
        background: rgba(130, 204, 221, 0.2);
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 0 16px var(--panel-glow), inset 0 0 12px var(--panel-glow);
      }

      .paint-mode-toggle .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-secondary);
        transition: all 0.25s ease;
      }

      .paint-mode-toggle.active .status-dot {
        background: var(--accent);
        box-shadow: 0 0 8px var(--accent);
        animation: pulse-glow 1.5s ease-in-out infinite;
      }

      @keyframes pulse-glow {
        0%, 100% { box-shadow: 0 0 8px var(--accent); }
        50% { box-shadow: 0 0 16px var(--accent), 0 0 24px var(--accent-glow); }
      }

      /* Lock Mode Toggle */
      .lock-mode-toggle {
        width: 100%;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text-secondary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        font-family: 'Outfit', sans-serif;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-top: 8px;
      }

      .lock-mode-toggle:hover {
        background: rgba(255, 193, 7, 0.1);
        border-color: rgba(255, 193, 7, 0.5);
        color: var(--text-primary);
      }

      .lock-mode-toggle.active {
        background: rgba(255, 193, 7, 0.2);
        border-color: #ffc107;
        color: #ffc107;
        box-shadow: 0 0 16px rgba(255, 193, 7, 0.2), inset 0 0 12px rgba(255, 193, 7, 0.1);
      }

      .lock-mode-toggle .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-secondary);
        transition: all 0.25s ease;
      }

      .lock-mode-toggle.active .status-dot {
        background: #ffc107;
        box-shadow: 0 0 8px #ffc107;
      }

      /* Lock Mode Indicator */
      #lockIndicator {
        position: fixed;
        bottom: 24px;
        right: 24px;
        transform: translateY(20px);
        padding: 12px 18px;
        background: var(--panel-bg);
        color: #ffc107;
        border: 1px solid rgba(255, 193, 7, 0.5);
        border-radius: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1.5px;
        pointer-events: none;
        cursor: pointer;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 150;
        box-shadow:
          0 0 40px rgba(255, 193, 7, 0.15),
          0 4px 20px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        display: flex;
        align-items: center;
        gap: 10px;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #lockIndicator.active {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      #lockIndicator.active:hover {
        background: rgba(12, 28, 44, 0.95);
        border-color: #ffc107;
        box-shadow:
          0 0 50px rgba(255, 193, 7, 0.2),
          0 4px 24px rgba(0, 0, 0, 0.5);
      }

      #lockIndicator.active:active {
        transform: translateY(2px);
      }

      #lockIndicator.active:active {
        transform: translateY(2px);
      }

      #lockIndicator .exit-x {
        font-size: 14px;
        opacity: 0.7;
        margin-left: 6px;
      }

      /* Paint Mode Indicator - clickable exit button */
      #paintIndicator {
        position: fixed;
        bottom: 24px;
        right: 24px;
        transform: translateY(20px);
        padding: 12px 18px;
        background: var(--panel-bg);
        color: var(--accent);
        border: 1px solid var(--accent-dim);
        border-radius: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1.5px;
        pointer-events: none;
        cursor: pointer;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 150;
        box-shadow:
          0 0 40px var(--panel-glow),
          0 4px 20px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        display: flex;
        align-items: center;
        gap: 10px;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #paintIndicator.active {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      #paintIndicator.active:hover {
        background: rgba(12, 28, 44, 0.95);
        border-color: var(--accent);
        box-shadow:
          0 0 50px var(--panel-glow),
          0 4px 24px rgba(0, 0, 0, 0.5);
      }

      #paintIndicator.active:active {
        transform: translateY(2px);
      }

      #paintIndicator .color-preview {
        width: 16px;
        height: 16px;
        border-radius: 4px;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      #paintIndicator .exit-x {
        font-size: 14px;
        opacity: 0.7;
        margin-left: 6px;
      }

      /* Action Buttons */
      .action-btn {
        width: 100%;
        padding: 11px 16px;
        background: rgba(255, 255, 255, 0.03);
        color: var(--text-primary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        font-family: 'Outfit', sans-serif;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        margin-top: 8px;
        letter-spacing: 0.3px;
      }

      .action-btn:first-child {
        margin-top: 0;
      }

      .action-btn:hover {
        background: rgba(130, 204, 221, 0.15);
        border-color: var(--accent-dim);
        color: var(--accent);
        box-shadow: 0 0 20px var(--panel-glow);
        transform: translateY(-1px);
      }

      .action-btn:active {
        transform: translateY(0);
      }

      .action-btn.danger {
        border-color: rgba(255, 107, 107, 0.3);
        color: var(--danger);
        margin-top: 16px;
      }

      .action-btn.danger:hover {
        background: rgba(255, 107, 107, 0.15);
        border-color: var(--danger);
        box-shadow: 0 0 20px var(--danger-glow);
      }

      /* Select Dropdown */
      .control-row select {
        padding: 6px 28px 6px 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-family: 'Outfit', sans-serif;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text-primary);
        outline: none;
        transition: all 0.2s ease;
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='rgba(130,204,221,0.7)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 8px center;
      }

      .control-row select:hover {
        border-color: var(--accent-dim);
        background-color: rgba(130, 204, 221, 0.08);
      }

      .control-row select:focus {
        border-color: var(--accent);
        box-shadow: 0 0 12px var(--panel-glow);
      }

      .control-row select option {
        background: #0c1c2c;
        color: var(--text-primary);
        padding: 8px;
      }

      /* ========== Freeze Indicator ========== */
      #freezeIndicator {
        position: fixed;
        bottom: 70px;
        right: 24px;
        transform: translateY(20px);
        padding: 12px 18px;
        background: var(--panel-bg);
        color: #4ecdc4;
        border: 1px solid rgba(78, 205, 196, 0.5);
        border-radius: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1.5px;
        pointer-events: none;
        cursor: pointer;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 150;
        box-shadow:
          0 0 40px rgba(78, 205, 196, 0.15),
          0 4px 20px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        display: flex;
        align-items: center;
        gap: 10px;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #freezeIndicator.active {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      #freezeIndicator.active:hover {
        background: rgba(12, 28, 44, 0.95);
        border-color: #4ecdc4;
        box-shadow:
          0 0 50px rgba(78, 205, 196, 0.25),
          0 4px 24px rgba(0, 0, 0, 0.5);
      }

      #freezeIndicator.active:active {
        transform: translateY(2px);
      }

      #freezeIndicator .exit-x {
        font-size: 14px;
        opacity: 0.7;
        margin-left: 6px;
      }

      /* ========== Modifier Indicators ========== */
      #modifiers {
        position: fixed;
        bottom: 24px;
        left: 24px;
        display: flex;
        gap: 12px;
        z-index: 100;
      }

      .modifier {
        padding: 10px 18px;
        background: var(--panel-bg);
        color: var(--accent);
        border: 1px solid var(--panel-border);
        border-radius: 10px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 2px;
        opacity: 0;
        transform: translateY(12px) scale(0.95);
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        box-shadow:
          0 4px 20px rgba(0, 0, 0, 0.4),
          0 0 30px var(--panel-glow);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        text-shadow: 0 0 10px var(--accent-glow);
      }

      .modifier.active {
        opacity: 1;
        transform: translateY(0) scale(1);
        border-color: var(--accent-dim);
        box-shadow:
          0 4px 20px rgba(0, 0, 0, 0.4),
          0 0 40px var(--panel-glow),
          inset 0 0 15px var(--panel-glow);
      }

      /* ========== Help Button ========== */
      #helpBtn {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 40px;
        height: 40px;
        background: var(--panel-bg);
        color: var(--accent);
        border: 1px solid var(--panel-border);
        border-radius: 50%;
        font-family: 'JetBrains Mono', monospace;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 100;
        box-shadow:
          0 4px 20px rgba(0, 0, 0, 0.4),
          0 0 20px var(--panel-glow);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      #helpBtn:hover {
        border-color: var(--accent-dim);
        transform: scale(1.1);
        box-shadow:
          0 4px 24px rgba(0, 0, 0, 0.5),
          0 0 30px var(--accent-glow);
      }

      #helpBtn:active {
        transform: scale(0.95);
      }

      /* ========== Help Modal ========== */
      #helpModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }

      #helpModal.visible {
        opacity: 1;
        visibility: visible;
      }

      #helpContent {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        padding: 32px;
        border-radius: 20px;
        max-width: 440px;
        font-family: 'Outfit', sans-serif;
        box-shadow:
          0 20px 60px rgba(0, 0, 0, 0.6),
          0 0 100px var(--panel-glow),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        transform: scale(0.95) translateY(10px);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #helpModal.visible #helpContent {
        transform: scale(1) translateY(0);
      }

      #helpContent h2 {
        margin: 0 0 24px 0;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 3px;
        text-transform: uppercase;
        color: var(--text-label);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      #helpContent h2::before {
        content: '';
        width: 4px;
        height: 4px;
        background: var(--accent);
        border-radius: 50%;
        box-shadow: 0 0 8px var(--accent);
      }

      #helpContent dl {
        margin: 0;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 12px 24px;
      }

      #helpContent dt {
        font-weight: 500;
        color: var(--text-primary);
        font-size: 13px;
      }

      #helpContent dd {
        margin: 0;
        color: var(--text-secondary);
        font-size: 13px;
      }

      #helpContent kbd {
        display: inline-block;
        padding: 3px 8px;
        background: rgba(130, 204, 221, 0.1);
        border: 1px solid var(--panel-border);
        border-radius: 5px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        color: var(--accent);
      }

      #closeHelp {
        margin-top: 28px;
        padding: 12px 28px;
        background: rgba(130, 204, 221, 0.15);
        color: var(--accent);
        border: 1px solid var(--accent-dim);
        border-radius: 10px;
        cursor: pointer;
        font-family: 'Outfit', sans-serif;
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 0.5px;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #closeHelp:hover {
        background: rgba(130, 204, 221, 0.25);
        box-shadow: 0 0 20px var(--panel-glow);
        transform: translateY(-1px);
      }

      #closeHelp:active {
        transform: translateY(0);
      }

      /* ========== Game HUDs ========== */
      .game-hud {
        position: fixed;
        top: 24px;
        left: 24px;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transform: translateY(-8px);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .game-hud.active {
        opacity: 1;
        transform: translateY(0);
      }

      .game-hud .hud-label {
        font-family: 'JetBrains Mono', monospace;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 3px;
        color: var(--text-label);
        margin-bottom: 4px;
      }

      .game-hud .hud-value {
        font-family: 'JetBrains Mono', monospace;
        font-size: 56px;
        font-weight: 600;
        color: var(--accent);
        text-shadow: 0 0 40px var(--accent-glow);
        line-height: 1;
        letter-spacing: -2px;
      }

      .game-hud .hud-sub {
        font-family: 'Outfit', sans-serif;
        font-size: 13px;
        color: var(--text-secondary);
        margin-top: 6px;
      }

      .game-hud .hud-success {
        font-family: 'JetBrains Mono', monospace;
        font-size: 14px;
        font-weight: 600;
        color: var(--accent);
        margin-top: 10px;
        text-shadow: 0 0 12px var(--accent-glow);
      }

      .game-hud .hud-warning {
        font-family: 'JetBrains Mono', monospace;
        font-size: 14px;
        font-weight: 600;
        color: var(--danger);
        margin-top: 10px;
        opacity: 0;
        transition: opacity 0.3s ease;
        text-shadow: 0 0 12px var(--danger-glow);
      }

      .game-hud .hud-warning.visible {
        opacity: 1;
      }

      /* ========== Chain Reaction HUD - Dramatic Arcade Style ========== */
      @keyframes chainPulse {
        0%, 100% {
          text-shadow: 0 0 40px var(--chain-glow), 0 0 80px var(--chain-glow);
          transform: scale(1);
        }
        50% {
          text-shadow: 0 0 60px var(--chain-glow), 0 0 120px var(--chain-glow), 0 0 180px var(--chain-glow);
          transform: scale(1.02);
        }
      }

      @keyframes chainLabelGlow {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
      }

      @keyframes scoreIncrement {
        0% { transform: scale(1.3); color: #fff; }
        100% { transform: scale(1); color: var(--chain-color); }
      }

      #chainScoreHUD {
        --chain-color: #ff6b35;
        --chain-glow: rgba(255, 107, 53, 0.6);
        --chain-bg: rgba(255, 107, 53, 0.08);
      }

      #chainScoreHUD.active {
        opacity: 1;
        transform: translateY(0);
      }

      #chainScoreHUD .hud-label {
        font-size: 11px;
        letter-spacing: 4px;
        color: var(--chain-color);
        text-shadow: 0 0 20px var(--chain-glow);
        margin-bottom: 2px;
      }

      #chainScoreHUD.chain-active .hud-label {
        animation: chainLabelGlow 1.5s ease-in-out infinite;
      }

      #chainScoreHUD .hud-value {
        font-size: 72px;
        font-weight: 600;
        color: var(--chain-color);
        text-shadow: 0 0 40px var(--chain-glow), 0 0 80px var(--chain-glow);
        line-height: 0.9;
        letter-spacing: -4px;
        transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #chainScoreHUD.chain-active .hud-value {
        animation: chainPulse 2s ease-in-out infinite;
      }

      #chainScoreHUD .hud-value.score-bump {
        animation: scoreIncrement 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #chainScoreHUD .hud-sub {
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        font-weight: 500;
        color: rgba(255, 107, 53, 0.7);
        margin-top: 8px;
        letter-spacing: 1px;
      }

      #chainScoreHUD .chain-multiplier {
        display: none;
        padding: 6px 12px;
        background: var(--chain-bg);
        border: 1px solid rgba(255, 107, 53, 0.3);
        border-radius: 6px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        color: var(--chain-color);
        margin-top: 14px;
        text-shadow: 0 0 10px var(--chain-glow);
        letter-spacing: 1px;
      }

      #chainScoreHUD.chain-active .chain-multiplier {
        animation: chainLabelGlow 1.5s ease-in-out infinite;
        box-shadow: 0 0 20px var(--chain-bg);
      }

      /* ========== GAME SCOREBOARD - Vintage Sports Card ========== */

      #gameBoard {
        position: fixed;
        bottom: 80px;
        left: 24px;
        z-index: 100;
        font-family: 'Oswald', sans-serif;
      }

      /* Collapsed Toggle Button */
      .scoreboard-toggle {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 16px;
        background: linear-gradient(180deg, #f5f0e6 0%, #ebe6d9 100%);
        border: 3px solid #1a1a1a;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      .scoreboard-toggle::before {
        content: '';
        position: absolute;
        inset: 0;
        background: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        opacity: 0.03;
        pointer-events: none;
        border-radius: 2px;
      }

      .scoreboard-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
      }

      .scoreboard-toggle:active {
        transform: translateY(0);
      }

      .toggle-game {
        font-family: 'Archivo Black', sans-serif;
        font-size: 11px;
        color: #1a1a1a;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .toggle-score {
        font-family: 'Archivo Black', sans-serif;
        font-size: 20px;
        color: #c41e3a;
        line-height: 1;
      }

      .toggle-arrow {
        font-size: 8px;
        color: #666;
        transition: transform 0.3s ease;
        margin-left: auto;
      }

      #gameBoard.open .toggle-arrow {
        transform: rotate(180deg);
      }

      /* Expanded Card */
      .scoreboard-card {
        background: linear-gradient(180deg, #f5f0e6 0%, #ebe6d9 100%);
        border: 3px solid #1a1a1a;
        border-radius: 4px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        min-width: 220px;
        position: relative;
        overflow: hidden;
        max-height: 0;
        opacity: 0;
        margin-top: 0;
        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #gameBoard.open .scoreboard-card {
        max-height: 450px;
        opacity: 1;
        margin-top: 10px;
      }

      .scoreboard-card::before {
        content: '';
        position: absolute;
        inset: 0;
        background: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        opacity: 0.03;
        pointer-events: none;
      }

      /* Game Tabs */
      .game-tabs {
        display: flex;
        border-bottom: 2px solid #1a1a1a;
        background: linear-gradient(180deg, #e8e3d6 0%, #ddd8c9 100%);
      }

      .game-tab {
        flex: 1;
        padding: 10px 8px;
        background: transparent;
        border: none;
        border-right: 1px solid rgba(0, 0, 0, 0.15);
        font-family: 'Oswald', sans-serif;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #666;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
      }

      .game-tab:last-child {
        border-right: none;
      }

      .game-tab:hover {
        background: rgba(0, 0, 0, 0.05);
        color: #333;
      }

      .game-tab.active {
        background: #f5f0e6;
        color: #c41e3a;
        box-shadow: inset 0 -3px 0 #c41e3a;
      }

      .game-tab.active::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        right: 0;
        height: 2px;
        background: #f5f0e6;
      }

      /* Scoreboard Content */
      .scoreboard-content {
        padding: 16px 20px 20px;
        display: none;
      }

      .scoreboard-content.active {
        display: block;
      }

      .score-header {
        font-family: 'Archivo Black', sans-serif;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #888;
        margin-bottom: 4px;
      }

      .score-main {
        font-family: 'Archivo Black', sans-serif;
        font-size: 52px;
        line-height: 1;
        color: #1a1a1a;
        letter-spacing: -2px;
        margin-bottom: 8px;
      }

      .score-main.highlight {
        color: #c41e3a;
      }

      .score-detail {
        font-family: 'Oswald', sans-serif;
        font-size: 13px;
        font-weight: 500;
        color: #666;
        letter-spacing: 0.5px;
        margin-bottom: 4px;
      }

      .score-detail strong {
        color: #1a1a1a;
        font-weight: 600;
      }

      .score-divider {
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(0,0,0,0.15), transparent);
        margin: 12px 0;
      }

      /* Action Buttons in Scoreboard */
      .scoreboard-actions {
        display: flex;
        gap: 8px;
        margin-top: 14px;
      }

      .score-btn {
        flex: 1;
        padding: 10px 12px;
        background: #1a1a1a;
        color: #f5f0e6;
        border: none;
        border-radius: 3px;
        font-family: 'Oswald', sans-serif;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .score-btn:hover {
        background: #c41e3a;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(196, 30, 58, 0.3);
      }

      .score-btn:active {
        transform: translateY(0);
      }

      .score-btn.secondary {
        background: transparent;
        color: #1a1a1a;
        border: 2px solid #1a1a1a;
      }

      .score-btn.secondary:hover {
        background: #1a1a1a;
        color: #f5f0e6;
      }

      /* Game-specific Scoreboard Styles */

      /* Chain Reaction */
      .chain-score-display {
        display: flex;
        align-items: baseline;
        gap: 8px;
      }

      .chain-score-display .score-main {
        margin-bottom: 0;
      }

      .chain-score-display .score-of {
        font-family: 'Oswald', sans-serif;
        font-size: 18px;
        color: #888;
      }

      .chain-pct {
        display: inline-block;
        padding: 4px 10px;
        background: #c41e3a;
        color: #fff;
        font-family: 'Archivo Black', sans-serif;
        font-size: 14px;
        border-radius: 2px;
        margin-left: 8px;
      }

      /* Golf */
      .golf-hole-display {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .golf-hole-num {
        font-family: 'Archivo Black', sans-serif;
        font-size: 14px;
        color: #1a1a1a;
      }

      .golf-par-badge {
        padding: 3px 10px;
        background: #1a1a1a;
        color: #f5f0e6;
        font-family: 'Oswald', sans-serif;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1px;
        border-radius: 2px;
      }

      .golf-result {
        font-family: 'Archivo Black', sans-serif;
        font-size: 16px;
        color: #c41e3a;
        margin-top: 8px;
      }

      /* Pinball */
      .pinball-bonus {
        display: inline-block;
        padding: 2px 8px;
        background: #ffd700;
        color: #1a1a1a;
        font-family: 'Oswald', sans-serif;
        font-size: 10px;
        font-weight: 700;
        border-radius: 2px;
        margin-left: 8px;
        animation: bonusPulse 1s ease-in-out infinite;
      }

      @keyframes bonusPulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      /* Cluster */
      .cluster-timer-display {
        font-family: 'Archivo Black', sans-serif;
        font-size: 48px;
        color: #1a1a1a;
        letter-spacing: 2px;
      }

      .cluster-danger {
        color: #c41e3a;
        animation: dangerPulse 0.5s ease-in-out infinite;
      }

      @keyframes dangerPulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }

      /* Sandbox (no game selected) */
      .sandbox-message {
        font-family: 'Oswald', sans-serif;
        font-size: 13px;
        color: #888;
        text-align: center;
        padding: 10px 0;
        font-style: italic;
      }

      /* Hide old HUDs - scoreboard handles all game display */
      #chainScoreHUD,
      #golfHUD,
      #pinballHUD,
      #clusterHUD {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <div id="chainScoreHUD" class="game-hud">
      <div class="hud-label">Chain</div>
      <div class="hud-value" id="chainScoreValue">0</div>
      <div class="hud-sub" id="chainBestValue"></div>
      <div class="chain-multiplier" id="chainMultiplier"></div>
    </div>

    <div id="golfHUD" class="game-hud">
      <div class="hud-label" id="golfHoleLabel">Hole 1</div>
      <div class="hud-value" id="golfStrokesValue">0</div>
      <div class="hud-sub" id="golfParLabel">Par 3</div>
      <div class="hud-sub" id="golfTotalLabel"></div>
      <div class="hud-success" id="golfCompleteLabel"></div>
    </div>

    <div id="pinballHUD" class="game-hud">
      <div class="hud-label">Pinball</div>
      <div class="hud-value" id="pinballScoreValue">0</div>
      <div class="hud-sub" id="pinballBestLabel">Best: 0</div>
    </div>

    <div id="clusterHUD" class="game-hud">
      <div class="hud-label">Cluster</div>
      <div class="hud-value" id="clusterTimerValue">0:00</div>
      <div class="hud-sub" id="clusterBestLabel">Best: 0:00</div>
      <div class="hud-warning" id="clusterWarning">CRITICAL MASS!</div>
    </div>

    <!-- Hidden game controls for backwards compatibility -->
    <input type="checkbox" id="chainReactionToggle" style="display:none" />
    <input type="checkbox" id="golfToggle" style="display:none" />
    <input type="checkbox" id="pinballToggle" style="display:none" />
    <input type="checkbox" id="clusterToggle" style="display:none" />
    <button id="chainStartBtn" style="display:none"></button>
    <button id="chainResetBtn" style="display:none"></button>
    <button id="golfStartBtn" style="display:none"></button>
    <button id="golfNextBtn" style="display:none"></button>
    <button id="pinballStartBtn" style="display:none"></button>
    <button id="clusterStartBtn" style="display:none"></button>
    <div id="chainThresholdRow" style="display:none">
      <input type="range" id="chainThresholdSlider" value="8" />
      <span id="chainThresholdValue">8</span>
    </div>

    <!-- Game Scoreboard -->
    <div id="gameBoard">
      <div class="scoreboard-toggle" id="scoreboardToggle">
        <span class="toggle-game" id="toggleGameName">Free Play</span>
        <span class="toggle-score" id="toggleScoreValue"></span>
        <span class="toggle-arrow">‚ñ≤</span>
      </div>
      <div class="scoreboard-card">
        <div class="game-tabs">
          <button class="game-tab active" data-game="sandbox">Free</button>
          <button class="game-tab" data-game="chain">Chain</button>
          <button class="game-tab" data-game="golf">Golf</button>
          <button class="game-tab" data-game="pinball">Pinball</button>
          <button class="game-tab" data-game="cluster">Cluster</button>
        </div>

        <!-- Sandbox (Free Play) -->
        <div class="scoreboard-content active" data-game="sandbox">
          <div class="sandbox-message">Double-click to create dots</div>
          <div class="score-detail"><strong id="sandboxDotCount">0</strong> dots in play</div>
        </div>

        <!-- Chain Reaction -->
        <div class="scoreboard-content" data-game="chain">
          <div class="score-header">Chain Hits</div>
          <div class="chain-score-display">
            <div class="score-main" id="chainScoreMain">0</div>
            <span class="score-of">/ <span id="chainTotalDots">0</span></span>
          </div>
          <div id="chainPctBadge" class="chain-pct" style="display: none;">0%</div>
          <div class="score-divider"></div>
          <div class="score-detail" id="chainStatusText">Place dots, then start</div>
          <div class="scoreboard-actions">
            <button class="score-btn" id="chainStartBtn2">Start Chain</button>
            <button class="score-btn secondary" id="chainResetBtn2">Reset</button>
          </div>
        </div>

        <!-- Golf -->
        <div class="scoreboard-content" data-game="golf">
          <div class="golf-hole-display">
            <span class="golf-hole-num" id="golfHoleNum">Hole 1</span>
            <span class="golf-par-badge" id="golfParBadge">PAR 3</span>
          </div>
          <div class="score-header">Strokes</div>
          <div class="score-main" id="golfStrokesMain">0</div>
          <div class="golf-result" id="golfResultText"></div>
          <div class="score-divider"></div>
          <div class="score-detail">Total: <strong id="golfTotalScore">E</strong></div>
          <div class="scoreboard-actions">
            <button class="score-btn" id="golfActionBtn">Start Hole</button>
          </div>
        </div>

        <!-- Pinball -->
        <div class="scoreboard-content" data-game="pinball">
          <div class="score-header">Score</div>
          <div class="score-main highlight" id="pinballScoreMain">0</div>
          <div class="score-divider"></div>
          <div class="score-detail">Best: <strong id="pinballBestScore">0</strong></div>
          <div class="scoreboard-actions">
            <button class="score-btn" id="pinballActionBtn">Start Round</button>
          </div>
        </div>

        <!-- Cluster -->
        <div class="scoreboard-content" data-game="cluster">
          <div class="score-header">Survival Time</div>
          <div class="cluster-timer-display" id="clusterTimerMain">0:00</div>
          <div class="score-divider"></div>
          <div class="score-detail">Best: <strong id="clusterBestTime">0:00</strong></div>
          <div class="score-detail" id="clusterWarningText" style="color: #c41e3a; display: none;">CRITICAL MASS!</div>
          <div class="scoreboard-actions">
            <button class="score-btn" id="clusterActionBtn">Start</button>
          </div>
        </div>
      </div>
    </div>

    <div id="modifiers">
      <div id="boostIndicator" class="modifier">BOOST</div>
      <div id="perpetualIndicator" class="modifier">‚àû PERPETUAL</div>
    </div>

    <div id="freezeIndicator">‚ùÑ FROZEN <span class="exit-x">‚úï</span></div>
    <div id="paintIndicator"><span class="color-preview" id="paintColorPreview"></span> PAINT <span class="exit-x">‚úï</span></div>
    <div id="lockIndicator">üîí LOCK <span class="exit-x">‚úï</span></div>

    <button id="helpBtn">?</button>

    <div id="helpModal">
      <div id="helpContent">
        <h2>Controls</h2>
        <dl>
          <dt>Create dot(s)</dt>
          <dd>Double-click empty space</dd>

          <dt>Grow dot</dt>
          <dd>Double-click stationary dot</dd>

          <dt>Shrink dot</dt>
          <dd>Hold on dot for 0.8s</dd>

          <dt>Stop moving dot</dt>
          <dd>Double-click moving dot</dd>

          <dt>Drag &amp; throw</dt>
          <dd>Click and drag, release to throw</dd>

          <dt><kbd>A</kbd> + drag</dt>
          <dd>Boost speed (3x faster)</dd>

          <dt><kbd>C</kbd> + release</dt>
          <dd>Perpetual motion (no friction)</dd>

          <dt><kbd>F</kbd></dt>
          <dd>Toggle freeze mode</dd>

          <dt><kbd>P</kbd></dt>
          <dd>Toggle paint mode</dd>

          <dt><kbd>L</kbd></dt>
          <dd>Toggle lock mode</dd>

          <dt><kbd>O</kbd></dt>
          <dd>Toggle orbit mode</dd>

          <dt><kbd>S</kbd></dt>
          <dd>Stop all dots</dd>

          <dt><kbd>?</kbd></dt>
          <dd>Toggle this help</dd>

          <dt><kbd>Esc</kbd></dt>
          <dd>Close panels</dd>

          <dt>Games</dt>
          <dd>Select from scoreboard (bottom-left)</dd>

          <dt>Debug</dt>
          <dd>Click ‚öô for physics settings</dd>
        </dl>
        <button id="closeHelp">Got it</button>
      </div>
    </div>

    <div id="controls">
      <button id="controlsToggle">‚öô</button>
      <div id="controlsPanel">
        <div class="control-section">
          <h3>Creation</h3>
          <div class="control-row">
            <label for="countSlider">Dots per click</label>
            <input type="range" id="countSlider" min="1" max="12" value="1" />
            <span class="value" id="countValue">1</span>
          </div>
        </div>

        <div class="control-section">
          <h3>Paint</h3>
          <div class="paint-palette">
            <div class="paint-swatch reset" data-color="reset" title="Reset to theme"></div>
            <div class="paint-swatch" data-color="#ff6b6b" style="background: #ff6b6b" title="Red"></div>
            <div class="paint-swatch" data-color="#ffa94d" style="background: #ffa94d" title="Orange"></div>
            <div class="paint-swatch" data-color="#ffd43b" style="background: #ffd43b" title="Yellow"></div>
            <div class="paint-swatch" data-color="#69db7c" style="background: #69db7c" title="Green"></div>
            <div class="paint-swatch" data-color="#4dabf7" style="background: #4dabf7" title="Blue"></div>
            <div class="paint-swatch" data-color="#da77f2" style="background: #da77f2" title="Purple"></div>
            <div class="paint-swatch" data-color="#ffffff" style="background: #ffffff" title="White"></div>
            <div class="paint-swatch" data-color="#1a1a2e" style="background: #1a1a2e; border: 1px solid rgba(255,255,255,0.2)" title="Black"></div>
          </div>
          <button class="paint-mode-toggle" id="paintModeToggle">
            <span class="status-dot"></span>
            Paint Mode <span class="kbd-hint">(P)</span>
          </button>
          <button class="lock-mode-toggle" id="lockModeToggle">
            <span class="status-dot"></span>
            Lock Mode <span class="kbd-hint">(L)</span>
          </button>
        </div>

        <div class="control-section">
          <h3>Modifiers</h3>
          <div class="modifier-toggles">
            <button class="toggle-btn" id="boostToggle">
              Boost <span class="kbd-hint">(A)</span>
            </button>
            <button class="toggle-btn" id="perpetualToggle">
              Perpetual <span class="kbd-hint">(C)</span>
            </button>
          </div>
        </div>

        <div class="control-section">
          <h3>Physics</h3>
          <div class="control-row">
            <label for="frictionSlider">Friction</label>
            <input
              type="range"
              id="frictionSlider"
              min="90"
              max="100"
              value="98"
              step="0.5"
            />
            <span class="value" id="frictionValue">98</span>
          </div>
          <div class="control-row">
            <label for="bounceSlider">Bounciness</label>
            <input
              type="range"
              id="bounceSlider"
              min="0"
              max="100"
              value="85"
            />
            <span class="value" id="bounceValue">85</span>
          </div>
        </div>

        <div class="control-section">
          <h3>Mode</h3>
          <div class="control-row">
            <label for="freezeToggle">Freeze</label>
            <input type="checkbox" id="freezeToggle" />
          </div>
          <div class="control-row">
            <label for="orbitToggle">Orbit <span class="kbd-hint">(O)</span></label>
            <input type="checkbox" id="orbitToggle" />
          </div>
          <div class="control-row" id="orbitStrengthRow" style="display: none;">
            <label for="orbitStrength">Pull</label>
            <input
              type="range"
              id="orbitStrength"
              min="1"
              max="100"
              value="50"
            />
            <span class="value" id="orbitStrengthValue">50</span>
          </div>
          <div class="orbit-hint" id="orbitHint" style="display: none; font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
            Click a dot to make it the attractor
          </div>
        </div>

        <div class="control-section">
          <h3>Display</h3>
          <div class="control-row">
            <label for="gridToggle">Show Grid</label>
            <input type="checkbox" id="gridToggle" />
          </div>
          <div class="control-row">
            <label for="themeSelect">Theme</label>
            <select id="themeSelect">
              <option value="orange">Orange</option>
              <option value="dark">Dark</option>
              <option value="light">Light</option>
              <option value="ocean" selected>Ocean</option>
              <option value="forest">Forest</option>
              <option value="sunset">Sunset</option>
            </select>
          </div>
        </div>

        <div class="control-section">
          <h3>Actions</h3>
          <button class="action-btn" id="stopAllBtn">Stop All Dots</button>
          <button class="action-btn" id="saveBtn">Save</button>
          <button class="action-btn" id="loadBtn">Load</button>
          <button class="action-btn danger" id="clearBtn">Clear All</button>
        </div>
      </div>
    </div>

    <script>
      /*
       * ========== POTENTIAL OPTIMIZATIONS ==========
       *
       * These optimizations are not currently needed but could be
       * implemented if performance becomes an issue with many dots.
       *
       * 1. SPATIAL PARTITIONING (Collision Detection)
       *    Current: O(n¬≤) - every dot checked against every other dot
       *    Solution: Divide screen into grid cells, only check dots in
       *    neighboring cells. Use cell size ~= largest dot diameter.
       *    Benefit: O(n) average case for evenly distributed dots
       *    When: 100+ dots with noticeable frame drops
       *
       * 2. OBJECT POOLING (Memory/GC)
       *    Current: Trail points created/destroyed frequently
       *    Solution: Pre-allocate pool of trail point objects, reuse them
       *    Benefit: Reduces garbage collection pauses
       *    When: Noticeable stuttering from GC during heavy trail usage
       *
       * 3. CANVAS RENDERING (Rendering)
       *    Current: SVG with D3 data binding
       *    Solution: Switch to Canvas 2D for dots/trails, keep SVG for UI
       *    Benefit: Much faster for many moving objects (no DOM updates)
       *    When: 200+ dots with trails causing frame drops
       *
       * 4. WEB WORKERS (Physics)
       *    Current: Physics runs on main thread
       *    Solution: Offload collision detection to Web Worker
       *    Benefit: Keeps UI responsive during heavy physics
       *    When: Physics calculations blocking input responsiveness
       *
       * 5. BROAD PHASE COLLISION (Collision Detection)
       *    Current: Circle-circle distance check for all pairs
       *    Solution: AABB (bounding box) check first, then precise check
       *    Benefit: AABB check is faster (no sqrt), rejects obvious misses
       *    When: Useful in combination with spatial partitioning
       *
       * 6. TRAIL PATH OPTIMIZATION (Rendering)
       *    Current: Each trail point is a separate SVG circle
       *    Solution: Use single SVG path or Canvas for each dot's trail
       *    Benefit: Fewer DOM nodes, faster rendering
       *    When: Many dots with long trails causing slowdown
       *
       * 7. FRAME SKIPPING (Physics)
       *    Current: Physics runs every animation frame
       *    Solution: Run physics at fixed timestep, interpolate for render
       *    Benefit: Consistent physics regardless of frame rate
       *    When: Physics behaves differently on high/low refresh displays
       */

      // Configuration
      const DEFAULT_RADIUS = 6;
      const MIN_RADIUS = 10;
      const MAX_RADIUS = 200;
      const HOLD_DURATION = 800;
      const GRID_SIZE = DEFAULT_RADIUS;
      const STROKE_WIDTH = 1.5;

      // Physics constants
      const BASE_FRICTION = 0.98;
      const MIN_VELOCITY = 0.1;
      const RESTITUTION = 0.85;
      const COLLISION_ITERATIONS = 4;

      // Freeze state
      let isFrozen = false;

      // Paint mode state
      let paintMode = false;
      let selectedPaintColor = null;

      // Lock mode state
      let lockMode = false;

      // Orbit mode state
      let orbitMode = false;
      let orbitSunId = null; // The central attractor dot
      const orbitingDots = new Set(); // Track which dots are orbiting
      const MAX_ORBITERS = 10;
      const ORBIT_GRAVITY = 0.08; // Gravitational pull strength
      const ORBIT_SUN_RADIUS = 40; // Size of the sun

      // Color themes
      const themes = {
        orange: {
          name: "Orange",
          background: "#be5504",
          dotFill: "#ffffff",
          dotStroke: "#000000",
          ui: "#000000",
        },
        dark: {
          name: "Dark",
          background: "#1a1a2e",
          dotFill: "#eaeaea",
          dotStroke: "#4a4a6a",
          ui: "#ffffff",
        },
        light: {
          name: "Light",
          background: "#f5f5f5",
          dotFill: "#333333",
          dotStroke: "#000000",
          ui: "#000000",
        },
        ocean: {
          name: "Ocean",
          background: "#0a3d62",
          dotFill: "#82ccdd",
          dotStroke: "#ffffff",
          ui: "#ffffff",
        },
        forest: {
          name: "Forest",
          background: "#1e3d2f",
          dotFill: "#a8e6cf",
          dotStroke: "#2d5a3f",
          ui: "#ffffff",
        },
        sunset: {
          name: "Sunset",
          background: "#2c1654",
          dotFill: "#ff6b6b",
          dotStroke: "#feca57",
          ui: "#ffffff",
        },
      };
      let currentTheme = "ocean";

      // State
      let dots = [];
      let nextId = 1;
      let holdTimer = null;
      let holdDotId = null;

      // Unified velocity state for ALL moving dots (dragged or thrown)
      let dotVelocities = new Map(); // dotId -> { vx, vy }

      // Drag state
      const DRAG_THRESHOLD = 5;
      const BOOST_MULTIPLIER = 3;
      let isDragging = false;
      let dragDotId = null;
      let dragStartPos = null;
      let dragOriginalPos = null;
      let dragTargetPos = null;
      let isBoostKeyHeld = false;
      let isNoFrictionKeyHeld = false;
      let noFrictionDots = new Set(); // Dots that should never decelerate
      let boostedDots = new Set(); // Dots that were thrown with boost (show trails)

      // Physics loop
      let physicsAnimationId = null;

      // Velocity tracking for throw release
      let velocityHistory = [];
      const VELOCITY_SAMPLES = 5;

      // Collision tracking
      let processedCollisions = new Set();

      // Touch support
      let lastTapTime = 0;
      let lastTapPos = null;
      const DOUBLE_TAP_THRESHOLD = 300;
      const DOUBLE_TAP_DISTANCE = 30;


      // Chain Reaction game state
      const CHAIN_IMPACT_THRESHOLD = 8;
      let chainReactionMode = false;
      let chainReactionActive = false;
      let chainReactionScore = 0;
      let chainReactionBest = 0;
      let chainReactionStartDotId = null;
      let chainWaitingForThrow = false;

      // Golf game state
      let golfMode = false;
      let golfBallId = null;
      let golfTarget = null; // {x, y, radius}
      let golfStrokes = 0;
      let golfPar = 3;
      let golfHoleNumber = 1;
      let golfTotalScore = 0;
      let golfHoleComplete = false;

      // Pinball game state
      let pinballMode = false;
      let pinballBallId = null;
      let pinballBumpers = []; // [{x, y, radius, points, type}]
      let pinballScore = 0;
      let pinballBest = 0;
      let pinballRoundActive = false;

      // Cluster game state
      let clusterMode = false;
      let clusterRoundActive = false;
      let clusterTimeElapsed = 0;
      let clusterBest = 0;
      let clusterTimerId = null;
      let clusterSpawnTimerId = null;
      let clusterDots = []; // [{id, x, y, vx, vy, radius, color, isBlack, clusterId, hitsTaken}]
      let clusterNextId = 1;
      let clusterGroups = new Map(); // clusterId -> [dotIds]
      let clusterNextGroupId = 1;
      let clusterSpawnInterval = 2000;
      let clusterDragDotId = null; // ID of black dot being dragged
      let clusterDragStartPos = null; // {x, y} of drag start
      let clusterDragOriginalPos = null; // Original dot position
      let clusterDragLastPos = null; // Last position for velocity calc
      let clusterDragVelocity = { vx: 0, vy: 0 }; // Accumulated velocity
      const CLUSTER_COLORS = ["#ffffff"]; // White cancer cells
      const CLUSTER_GRAVITY = 0.8; // Strong attraction between cells
      const CLUSTER_MERGE_SIZE = 4; // Dots needed to merge into larger

      // ========== UNIFIED MASS FUNCTION ==========
      // Area-based mass: (radius / DEFAULT_RADIUS)^2
      function mass(dot) {
        const ratio = dot.radius / DEFAULT_RADIUS;
        return ratio * ratio;
      }

      // ========== SETUP SVG ==========
      // ========== CANVAS SETUP ==========
      const gameCanvas = document.getElementById("gameCanvas");
      const ctx = gameCanvas.getContext("2d");
      gameCanvas.width = window.innerWidth;
      gameCanvas.height = window.innerHeight;

      // ========== HIT DETECTION ==========
      function findDotAtPoint(x, y, dotArray = dots) {
        // Search in reverse order so topmost dots are found first
        for (let i = dotArray.length - 1; i >= 0; i--) {
          const dot = dotArray[i];
          const dx = x - dot.x;
          const dy = y - dot.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= dot.radius) {
            return dot;
          }
        }
        return null;
      }

      function findClusterDotAtPoint(x, y) {
        return findDotAtPoint(x, y, clusterDots);
      }

      // Grid visibility state
      let showGrid = false;

      window.addEventListener("resize", () => {
        gameCanvas.width = window.innerWidth;
        gameCanvas.height = window.innerHeight;
        renderCanvas();
      });

      // ========== CANVAS EVENT HANDLERS ==========
      function getCanvasCoords(event) {
        const rect = gameCanvas.getBoundingClientRect();
        if (event.touches) {
          return {
            x: event.touches[0].clientX - rect.left,
            y: event.touches[0].clientY - rect.top
          };
        }
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top
        };
      }

      // Track hovered dot for cursor changes
      gameCanvas.addEventListener("mousemove", function(event) {
        const coords = getCanvasCoords(event);

        // Handle cluster drag
        if (clusterDragDotId !== null) {
          const dx = coords.x - clusterDragStartPos.x;
          const dy = coords.y - clusterDragStartPos.y;
          const dot = clusterDots.find((d) => d.id === clusterDragDotId);
          if (dot) {
            const newX = clusterDragOriginalPos.x + dx;
            const newY = clusterDragOriginalPos.y + dy;
            if (clusterDragLastPos) {
              clusterDragVelocity.vx = (newX - clusterDragLastPos.x) * 0.5 + clusterDragVelocity.vx * 0.5;
              clusterDragVelocity.vy = (newY - clusterDragLastPos.y) * 0.5 + clusterDragVelocity.vy * 0.5;
            }
            clusterDragLastPos = { x: newX, y: newY };
            dot.x = Math.max(dot.radius, Math.min(window.innerWidth - dot.radius, newX));
            dot.y = Math.max(dot.radius, Math.min(window.innerHeight - dot.radius, newY));
          }
          return;
        }

        // Handle regular dot drag
        if (dragDotId !== null) {
          const dx = coords.x - dragStartPos.x;
          const dy = coords.y - dragStartPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (!isDragging && distance > DRAG_THRESHOLD) {
            isDragging = true;
            clearHoldTimer();
            gameCanvas.classList.add("dragging");
            startPhysicsLoop();
          }

          if (isDragging) {
            dragTargetPos = {
              x: dragOriginalPos.x + dx,
              y: dragOriginalPos.y + dy,
            };
          }
          return;
        }

        // Update cursor based on hover
        const dot = findDotAtPoint(coords.x, coords.y);
        const clusterDot = clusterMode ? findClusterDotAtPoint(coords.x, coords.y) : null;
        if (dot || (clusterDot && clusterDot.isBlack)) {
          gameCanvas.classList.add("hovering-dot");
        } else {
          gameCanvas.classList.remove("hovering-dot");
        }
      });

      gameCanvas.addEventListener("mousedown", function(event) {
        const coords = getCanvasCoords(event);

        // Check cluster dots first (in cluster mode)
        if (clusterMode) {
          const clusterDot = findClusterDotAtPoint(coords.x, coords.y);
          if (clusterDot && clusterDot.isBlack) {
            clusterDragDotId = clusterDot.id;
            clusterDragStartPos = { x: coords.x, y: coords.y };
            clusterDragOriginalPos = { x: clusterDot.x, y: clusterDot.y };
            gameCanvas.classList.add("dragging");
            return;
          }
        }

        // Check regular dots
        const dot = findDotAtPoint(coords.x, coords.y);
        if (dot) {
          handleDotMouseDown(dot, coords.x, coords.y);
        }
      });

      gameCanvas.addEventListener("mouseup", function(event) {
        // Always clear hold timer on release to prevent orphaned shrink timers
        clearHoldTimer();

        if (clusterDragDotId !== null) {
          finalizeClusterDrag();
          return;
        }
        finalizeDrag();
        gameCanvas.classList.remove("dragging");
      });

      gameCanvas.addEventListener("mouseleave", function(event) {
        if (!isDragging) {
          clearHoldTimer();
        }
        gameCanvas.classList.remove("hovering-dot");
      });

      gameCanvas.addEventListener("dblclick", function(event) {
        event.preventDefault();
        const coords = getCanvasCoords(event);
        const dot = findDotAtPoint(coords.x, coords.y);
        if (dot) {
          handleDotDoubleClick(dot);
        } else {
          createDot(coords.x, coords.y);
        }
      });

      // Touch events
      gameCanvas.addEventListener("touchstart", function(event) {
        event.preventDefault();
        const coords = getCanvasCoords(event);

        // Check cluster dots first
        if (clusterMode) {
          const clusterDot = findClusterDotAtPoint(coords.x, coords.y);
          if (clusterDot && clusterDot.isBlack) {
            clusterDragDotId = clusterDot.id;
            clusterDragStartPos = { x: coords.x, y: coords.y };
            clusterDragOriginalPos = { x: clusterDot.x, y: clusterDot.y };
            gameCanvas.classList.add("dragging");
            return;
          }
        }

        // Check regular dots
        const dot = findDotAtPoint(coords.x, coords.y);
        const touch = event.touches[0];
        const now = Date.now();

        // Check for double-tap
        if (lastTapTime && now - lastTapTime < DOUBLE_TAP_THRESHOLD && lastTapPos) {
          const dist = Math.sqrt((touch.clientX - lastTapPos.x) ** 2 + (touch.clientY - lastTapPos.y) ** 2);
          if (dist < DOUBLE_TAP_DISTANCE) {
            lastTapTime = 0;
            lastTapPos = null;
            if (dot) {
              handleDotDoubleClick(dot);
            } else {
              createDot(coords.x, coords.y);
            }
            return;
          }
        }
        lastTapTime = now;
        lastTapPos = { x: touch.clientX, y: touch.clientY };

        if (dot) {
          handleDotTouchStart(dot, coords.x, coords.y);
        }
      }, { passive: false });

      gameCanvas.addEventListener("touchmove", function(event) {
        event.preventDefault();
        const coords = getCanvasCoords(event);

        if (clusterDragDotId !== null) {
          const dx = coords.x - clusterDragStartPos.x;
          const dy = coords.y - clusterDragStartPos.y;
          const dot = clusterDots.find((d) => d.id === clusterDragDotId);
          if (dot) {
            const newX = clusterDragOriginalPos.x + dx;
            const newY = clusterDragOriginalPos.y + dy;
            if (clusterDragLastPos) {
              clusterDragVelocity.vx = (newX - clusterDragLastPos.x) * 0.5 + clusterDragVelocity.vx * 0.5;
              clusterDragVelocity.vy = (newY - clusterDragLastPos.y) * 0.5 + clusterDragVelocity.vy * 0.5;
            }
            clusterDragLastPos = { x: newX, y: newY };
            dot.x = Math.max(dot.radius, Math.min(window.innerWidth - dot.radius, newX));
            dot.y = Math.max(dot.radius, Math.min(window.innerHeight - dot.radius, newY));
          }
          return;
        }

        if (dragDotId !== null) {
          const dx = coords.x - dragStartPos.x;
          const dy = coords.y - dragStartPos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (!isDragging && distance > DRAG_THRESHOLD) {
            isDragging = true;
            clearHoldTimer();
            gameCanvas.classList.add("dragging");
            startPhysicsLoop();
          }

          if (isDragging) {
            dragTargetPos = {
              x: dragOriginalPos.x + dx,
              y: dragOriginalPos.y + dy,
            };
          }
        }
      }, { passive: false });

      gameCanvas.addEventListener("touchend", function(event) {
        // Always clear hold timer on release to prevent orphaned shrink timers
        clearHoldTimer();

        if (clusterDragDotId !== null) {
          finalizeClusterDrag();
          return;
        }
        finalizeDrag();
        gameCanvas.classList.remove("dragging");
      });

      // ========== DOT INTERACTION HANDLERS ==========
      function handleDotMouseDown(d, mx, my) {
        // Handle paint mode
        if (paintMode && selectedPaintColor) {
          if (selectedPaintColor === "reset") {
            delete d.color;
          } else {
            d.color = selectedPaintColor;
          }
          render();
          return;
        }

        // Handle lock mode
        if (lockMode) {
          d.locked = !d.locked;
          if (d.locked) {
            dotVelocities.delete(d.id);
            noFrictionDots.delete(d.id);
            boostedDots.delete(d.id);
          }
          render();
          return;
        }

        // Handle orbit mode - click to set attractor
        if (orbitMode && orbitSunId === null) {
          setOrbitAttractor(d);
          return;
        }

        // Don't allow dragging locked dots
        if (d.locked) return;

        holdDotId = d.id;
        dragStartPos = { x: mx, y: my };
        dragOriginalPos = { x: d.x, y: d.y };
        dragDotId = d.id;
        isDragging = false;

        if (!dotVelocities.has(d.id)) {
          dotVelocities.set(d.id, { vx: 0, vy: 0 });
        }

        holdTimer = setTimeout(() => {
          if (holdDotId === d.id && !isDragging) {
            shrinkDot(d.id);
          }
          clearHoldTimer();
        }, HOLD_DURATION);
      }

      function handleDotTouchStart(d, tx, ty) {
        // Handle paint mode
        if (paintMode && selectedPaintColor) {
          if (selectedPaintColor === "reset") {
            delete d.color;
          } else {
            d.color = selectedPaintColor;
          }
          render();
          return;
        }

        // Handle lock mode
        if (lockMode) {
          d.locked = !d.locked;
          if (d.locked) {
            dotVelocities.delete(d.id);
            noFrictionDots.delete(d.id);
            boostedDots.delete(d.id);
          }
          render();
          return;
        }

        // Handle orbit mode
        if (orbitMode && orbitSunId === null) {
          setOrbitAttractor(d);
          return;
        }

        if (d.locked) return;

        holdDotId = d.id;
        dragStartPos = { x: tx, y: ty };
        dragOriginalPos = { x: d.x, y: d.y };
        dragDotId = d.id;
        isDragging = false;

        if (!dotVelocities.has(d.id)) {
          dotVelocities.set(d.id, { vx: 0, vy: 0 });
        }

        holdTimer = setTimeout(() => {
          if (holdDotId === d.id && !isDragging) {
            shrinkDot(d.id);
          }
          clearHoldTimer();
        }, HOLD_DURATION);
      }

      function handleDotDoubleClick(d) {
        clearHoldTimer();

        if (dotVelocities.has(d.id)) {
          const vel = dotVelocities.get(d.id);
          const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
          if (speed > MIN_VELOCITY) {
            dotVelocities.delete(d.id);
            noFrictionDots.delete(d.id);
            const snapped = snapToGrid(d.x, d.y);
            if (!wouldOverlap(snapped.x, snapped.y, d.radius, d.id)) {
              d.x = snapped.x;
              d.y = snapped.y;
            }
            render();
            return;
          }
        }

        growDot(d.id);
      }

      // ========== UTILITY FUNCTIONS ==========
      const snapToGrid = (x, y) => ({
        x: Math.round(x / GRID_SIZE) * GRID_SIZE,
        y: Math.round(y / GRID_SIZE) * GRID_SIZE,
      });

      const wouldOverlap = (x, y, radius, excludeId = null) => {
        return dots.some((dot) => {
          if (dot.id === excludeId) return false;
          const dx = dot.x - x;
          const dy = dot.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < radius + dot.radius;
        });
      };

      const findPlacementPosition = (clickX, clickY, newRadius) => {
        if (dots.length === 0) {
          return snapToGrid(clickX, clickY);
        }

        let nearestDot = null;
        let nearestDistance = Infinity;
        for (const dot of dots) {
          const dx = clickX - dot.x;
          const dy = clickY - dot.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDistance) {
            nearestDistance = dist;
            nearestDot = dot;
          }
        }

        const touchDistance =
          nearestDot.radius + Math.max(newRadius, nearestDot.radius);

        if (nearestDistance > touchDistance * 2) {
          return snapToGrid(clickX, clickY);
        }

        const dx = clickX - nearestDot.x;
        const dy = clickY - nearestDot.y;

        if (nearestDistance === 0) {
          return { x: nearestDot.x + touchDistance, y: nearestDot.y };
        }

        const nx = dx / nearestDistance;
        const ny = dy / nearestDistance;

        return snapToGrid(
          nearestDot.x + nx * touchDistance,
          nearestDot.y + ny * touchDistance,
        );
      };

      // ========== UNIFIED COLLISION SOLVER ==========
      // Resolves collision between two dots using impulse-based elastic collision
      // Updates velocities and separates positions
      // Locked dots act as immovable obstacles (infinite mass)
      function resolveCollision(dotA, dotB, velA, velB) {
        const dx = dotB.x - dotA.x;
        const dy = dotB.y - dotA.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = dotA.radius + dotB.radius;

        if (dist >= minDist || dist === 0) return false;

        // Collision normal (from A to B)
        const nx = dx / dist;
        const ny = dy / dist;

        // Handle locked dots as immovable (infinite mass)
        const aLocked = dotA.locked;
        const bLocked = dotB.locked;

        // Both locked = no collision response needed
        if (aLocked && bLocked) return false;

        // Masses (locked dots treated as infinite mass)
        const mA = aLocked ? Infinity : mass(dotA);
        const mB = bLocked ? Infinity : mass(dotB);

        // Relative velocity (A relative to B)
        const relVx = velA.vx - velB.vx;
        const relVy = velA.vy - velB.vy;

        // Relative velocity along collision normal
        const relVelNormal = relVx * nx + relVy * ny;

        // Only resolve if moving toward each other
        if (relVelNormal > 0) {
          const restitution = getRestitution();

          if (aLocked) {
            // A is immovable - B bounces off
            const impulse = (1 + restitution) * relVelNormal * mB;
            velB.vx += (impulse / mB) * nx;
            velB.vy += (impulse / mB) * ny;
          } else if (bLocked) {
            // B is immovable - A bounces off
            const impulse = (1 + restitution) * relVelNormal * mA;
            velA.vx -= (impulse / mA) * nx;
            velA.vy -= (impulse / mA) * ny;
          } else {
            // Normal collision between two movable dots
            const totalMass = mA + mB;
            const impulse =
              ((1 + restitution) * relVelNormal) / (1 / mA + 1 / mB);

            velA.vx -= (impulse / mA) * nx;
            velA.vy -= (impulse / mA) * ny;
            velB.vx += (impulse / mB) * nx;
            velB.vy += (impulse / mB) * ny;
          }

          // Chain Reaction: propagate boost on hard collision
          if (chainReactionMode && chainReactionActive) {
            const impactSpeed = Math.abs(relVelNormal);
            const threshold = getChainThreshold();

            if (impactSpeed >= threshold) {
              const aIsBoosted = boostedDots.has(dotA.id);
              const bIsBoosted = boostedDots.has(dotB.id);

              if (aIsBoosted && !bIsBoosted && !bLocked) {
                boostedDots.add(dotB.id);
                chainReactionScore++;
                updateChainScoreDisplay();
              }
              if (bIsBoosted && !aIsBoosted && !aLocked) {
                boostedDots.add(dotA.id);
                chainReactionScore++;
                updateChainScoreDisplay();
              }
            }
          }
        }

        // Positional separation
        const overlap = minDist - dist;

        if (aLocked) {
          // Only move B
          dotB.x += nx * overlap;
          dotB.y += ny * overlap;
        } else if (bLocked) {
          // Only move A
          dotA.x -= nx * overlap;
          dotA.y -= ny * overlap;
        } else {
          // Mass-proportional separation
          const totalMass = mA + mB;
          const separationA = overlap * (mB / totalMass);
          const separationB = overlap * (mA / totalMass);

          dotA.x -= nx * separationA;
          dotA.y -= ny * separationA;
          dotB.x += nx * separationB;
          dotB.y += ny * separationB;
        }

        return true;
      }


      // ========== CHAIN REACTION GAME ==========
      function getChainThreshold() {
        const slider = document.getElementById("chainThresholdSlider");
        return slider ? parseFloat(slider.value) : CHAIN_IMPACT_THRESHOLD;
      }

      function startChainReactionRound(startDotId) {
        chainReactionActive = true;
        chainReactionScore = 1; // The thrown dot counts
        chainReactionStartDotId = startDotId;
        updateChainScoreDisplay();
      }

      function endChainReactionRound() {
        chainReactionActive = false;
        if (chainReactionScore > chainReactionBest) {
          chainReactionBest = chainReactionScore;
        }
        updateChainScoreDisplay();
        chainReactionStartDotId = null;
      }

      function resetChainReaction() {
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();

        chainReactionActive = false;
        chainReactionScore = 0;
        chainReactionStartDotId = null;
        updateChainScoreDisplay();
        render();
      }

      let lastChainScore = 0;

      function updateChainScoreDisplay() {
        const hud = document.getElementById("chainScoreHUD");
        const scoreEl = document.getElementById("chainScoreValue");
        const bestEl = document.getElementById("chainBestValue");
        const multiplierEl = document.getElementById("chainMultiplier");
        if (!scoreEl || !hud) return;

        // Add score bump animation when score increases
        if (chainReactionScore > lastChainScore && chainReactionActive) {
          scoreEl.classList.remove("score-bump");
          void scoreEl.offsetWidth; // Trigger reflow to restart animation
          scoreEl.classList.add("score-bump");
        }
        lastChainScore = chainReactionScore;

        scoreEl.textContent = chainReactionScore;

        // Toggle chain-active class for pulsing effects
        hud.classList.toggle("chain-active", chainReactionActive);

        // Update best label
        const parts = [];
        if (chainReactionBest > 0) {
          parts.push("Best: " + chainReactionBest);
        }
        if (chainReactionActive) {
          parts.push(dots.length + " dots");
        } else if (chainReactionScore > 0) {
          parts.push("Hit " + chainReactionScore + "/" + dots.length);
        }
        bestEl.textContent = parts.join(" ¬∑ ");

        // Update multiplier display
        if (chainReactionActive && dots.length > 0) {
          const percentage = Math.round((chainReactionScore / dots.length) * 100);
          multiplierEl.textContent = percentage + "% CHAIN";
          multiplierEl.style.display = "inline-block";
        } else if (!chainReactionActive && chainReactionScore > 0) {
          const percentage = Math.round((chainReactionScore / dots.length) * 100);
          multiplierEl.textContent = percentage + "% HIT";
          multiplierEl.style.display = "inline-block";
        } else {
          multiplierEl.style.display = "none";
        }
      }

      // ========== GOLF GAME ==========
      function startGolfHole() {
        // Clear any existing dots
        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();

        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 100;

        // Place target randomly on right side
        golfTarget = {
          x: width - margin - Math.random() * (width / 3),
          y: margin + Math.random() * (height - margin * 2),
          radius: 40,
        };

        // Calculate par based on distance from start
        const startX = margin;
        const startY = height / 2;
        const dist = Math.sqrt(
          (golfTarget.x - startX) ** 2 + (golfTarget.y - startY) ** 2,
        );
        if (dist < 300) golfPar = 2;
        else if (dist < 500) golfPar = 3;
        else golfPar = 4;

        // Create ball at start position
        const ballDot = {
          id: nextId++,
          x: startX,
          y: startY,
          radius: DEFAULT_RADIUS,
        };
        dots.push(ballDot);
        golfBallId = ballDot.id;

        golfStrokes = 0;
        golfHoleComplete = false;

        renderGolfTarget();
        updateGolfHUD();
        render();

        // Show/hide buttons
        document.getElementById("golfStartBtn").style.display = "none";
        document.getElementById("golfNextBtn").style.display = "none";
      }

      function endGolfHole() {
        golfHoleComplete = true;
        const diff = golfStrokes - golfPar;
        golfTotalScore += diff;

        updateGolfHUD();

        // Show next hole button
        document.getElementById("golfNextBtn").style.display = "block";
      }

      function nextGolfHole() {
        golfHoleNumber++;
        startGolfHole();
      }

      function resetGolf() {
        golfBallId = null;
        golfTarget = null;
        golfStrokes = 0;
        golfPar = 3;
        golfHoleNumber = 1;
        golfTotalScore = 0;
        golfHoleComplete = false;

        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        render();
        updateGolfHUD();
      }

      function checkGolfWin() {
        if (!golfMode || !golfBallId || !golfTarget || golfHoleComplete) return;

        const ball = dots.find((d) => d.id === golfBallId);
        if (!ball) return;

        // Ball must be stopped (not in velocities map)
        if (dotVelocities.has(golfBallId)) return;

        // Check if ball center is within target
        const dx = ball.x - golfTarget.x;
        const dy = ball.y - golfTarget.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= golfTarget.radius) {
          endGolfHole();
        }
      }

      function renderGolfTarget() {
        // Golf target is now rendered on canvas in renderCanvas()
        renderCanvas();
      }

      function updateGolfHUD() {
        const holeLabel = document.getElementById("golfHoleLabel");
        const strokesValue = document.getElementById("golfStrokesValue");
        const parLabel = document.getElementById("golfParLabel");
        const totalLabel = document.getElementById("golfTotalLabel");
        const completeLabel = document.getElementById("golfCompleteLabel");

        if (!holeLabel) return;

        holeLabel.textContent = "Hole " + golfHoleNumber;
        strokesValue.textContent = golfStrokes;
        parLabel.textContent = "Par " + golfPar;

        if (golfTotalScore === 0) {
          totalLabel.textContent = "";
        } else if (golfTotalScore > 0) {
          totalLabel.textContent = "Total: +" + golfTotalScore;
        } else {
          totalLabel.textContent = "Total: " + golfTotalScore;
        }

        if (golfHoleComplete) {
          const diff = golfStrokes - golfPar;
          let msg = "";
          if (diff === -2) msg = "Eagle!";
          else if (diff === -1) msg = "Birdie!";
          else if (diff === 0) msg = "Par";
          else if (diff === 1) msg = "Bogey";
          else if (diff === 2) msg = "Double Bogey";
          else if (diff > 2) msg = "+" + diff;
          else msg = diff.toString();
          completeLabel.textContent = msg;
        } else {
          completeLabel.textContent = "";
        }
      }

      // ========== PINBALL GAME ==========
      function startPinballRound() {
        // Clear any existing dots
        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();

        // Place bumpers
        placeBumpers();
        renderBumpers();

        // Create ball at start position
        const width = window.innerWidth;
        const height = window.innerHeight;
        const ballDot = {
          id: nextId++,
          x: 100,
          y: height / 2,
          radius: DEFAULT_RADIUS,
        };
        dots.push(ballDot);
        pinballBallId = ballDot.id;

        pinballScore = 0;
        pinballRoundActive = false; // Will become active on first throw

        updatePinballHUD();
        render();

        document.getElementById("pinballStartBtn").textContent = "Start Round";
      }

      function endPinballRound() {
        pinballRoundActive = false;
        if (pinballScore > pinballBest) {
          pinballBest = pinballScore;
        }
        updatePinballHUD();
        document.getElementById("pinballStartBtn").style.display = "block";
      }

      function resetPinball() {
        pinballBallId = null;
        pinballBumpers = [];
        pinballScore = 0;
        pinballRoundActive = false;

        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        render();
        updatePinballHUD();
      }

      function placeBumpers() {
        pinballBumpers = [];
        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 120;
        const bumperRadius = 30;

        // Place 5-8 bumpers
        const count = 5 + Math.floor(Math.random() * 4);

        for (let i = 0; i < count; i++) {
          let attempts = 0;
          let placed = false;

          while (!placed && attempts < 50) {
            const x = margin + Math.random() * (width - margin * 2);
            const y = margin + Math.random() * (height - margin * 2);

            // Check overlap with other bumpers
            let overlaps = false;
            for (const other of pinballBumpers) {
              const dist = Math.sqrt((x - other.x) ** 2 + (y - other.y) ** 2);
              if (dist < bumperRadius * 2 + 40) {
                overlaps = true;
                break;
              }
            }

            if (!overlaps) {
              const isBonus = Math.random() < 0.2; // 20% chance of bonus
              pinballBumpers.push({
                x,
                y,
                radius: bumperRadius,
                points: isBonus ? 25 : 10,
                type: isBonus ? "bonus" : "standard",
              });
              placed = true;
            }
            attempts++;
          }
        }
      }

      function renderBumpers() {
        // Bumpers are now rendered on canvas in renderCanvas()
        renderCanvas();
      }

      function updatePinballHUD() {
        const scoreValue = document.getElementById("pinballScoreValue");
        const bestLabel = document.getElementById("pinballBestLabel");

        if (!scoreValue) return;

        scoreValue.textContent = pinballScore;
        bestLabel.textContent = "Best: " + pinballBest;
      }

      // ========== CLUSTER GAME ==========
      function startClusterRound() {
        // Clear existing state
        clusterDots = [];
        clusterGroups.clear();
        clusterNextId = 1;
        clusterNextGroupId = 1;
        clusterTimeElapsed = 0;
        clusterSpawnInterval = 2000;

        clusterRoundActive = true;

        // Create initial black dot in center
        const width = window.innerWidth;
        const height = window.innerHeight;
        clusterDots.push({
          id: clusterNextId++,
          x: width / 2,
          y: height / 2,
          vx: 0,
          vy: 0,
          radius: 15,
          color: "#222222",
          isBlack: true,
          clusterId: null,
          hitsTaken: 0,
        });

        updateClusterHUD();
        renderClusterDots();

        // Start timer
        clusterTimerId = setInterval(clusterTick, 1000);

        // Start spawning colored dots
        clusterSpawnTimerId = setTimeout(spawnClusterDot, 1000);

        document.getElementById("clusterStartBtn").style.display = "none";

        // Start physics loop
        startPhysicsLoop();
      }

      function endClusterRound() {
        clusterRoundActive = false;

        if (clusterTimerId) {
          clearInterval(clusterTimerId);
          clusterTimerId = null;
        }

        if (clusterSpawnTimerId) {
          clearTimeout(clusterSpawnTimerId);
          clusterSpawnTimerId = null;
        }

        if (clusterTimeElapsed > clusterBest) {
          clusterBest = clusterTimeElapsed;
        }

        updateClusterHUD();
        document.getElementById("clusterStartBtn").style.display = "block";
        document.getElementById("clusterStartBtn").textContent = "Try Again";
      }

      function resetCluster() {
        clusterRoundActive = false;

        if (clusterTimerId) {
          clearInterval(clusterTimerId);
          clusterTimerId = null;
        }

        if (clusterSpawnTimerId) {
          clearTimeout(clusterSpawnTimerId);
          clusterSpawnTimerId = null;
        }

        clusterDots = [];
        clusterGroups.clear();
        clusterNextId = 1;
        clusterNextGroupId = 1;
        clusterTimeElapsed = 0;
        clusterSpawnInterval = 2000;

        updateClusterHUD();
      }

      function spawnClusterDot() {
        if (!clusterRoundActive) return;

        const width = window.innerWidth;
        const height = window.innerHeight;
        const radius = 15;

        // Spawn from random edge
        const edge = Math.floor(Math.random() * 4);
        let x, y, vx, vy;
        const speed = 0.5 + Math.random() * 0.5;

        switch (edge) {
          case 0: // top
            x = Math.random() * width;
            y = -radius;
            vx = (Math.random() - 0.5) * 2;
            vy = speed;
            break;
          case 1: // right
            x = width + radius;
            y = Math.random() * height;
            vx = -speed;
            vy = (Math.random() - 0.5) * 2;
            break;
          case 2: // bottom
            x = Math.random() * width;
            y = height + radius;
            vx = (Math.random() - 0.5) * 2;
            vy = -speed;
            break;
          case 3: // left
            x = -radius;
            y = Math.random() * height;
            vx = speed;
            vy = (Math.random() - 0.5) * 2;
            break;
        }

        // Random color
        const color =
          CLUSTER_COLORS[Math.floor(Math.random() * CLUSTER_COLORS.length)];

        clusterDots.push({
          id: clusterNextId++,
          x,
          y,
          vx,
          vy,
          radius,
          color,
          isBlack: false,
          clusterId: null,
          hitsTaken: 0,
        });

        // Schedule next spawn (gets faster over time)
        clusterSpawnTimerId = setTimeout(spawnClusterDot, clusterSpawnInterval);
      }

      function updateClusterPhysics() {
        if (!clusterRoundActive) return;

        const width = window.innerWidth;
        const height = window.innerHeight;

        // Move all dots
        for (const dot of clusterDots) {
          // Skip dot being dragged
          if (dot.id === clusterDragDotId) continue;

          if (!dot.isBlack) {
            // Colored dots: Apply gravity toward same-colored dots
            for (const other of clusterDots) {
              if (
                other.id === dot.id ||
                other.isBlack ||
                other.color !== dot.color
              )
                continue;

              const dx = other.x - dot.x;
              const dy = other.y - dot.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist > 0 && dist < 300) {
                const force = CLUSTER_GRAVITY / (dist * 0.1);
                dot.vx += (dx / dist) * force;
                dot.vy += (dy / dist) * force;
              }
            }
          }

          // Apply friction
          dot.vx *= 0.98;
          dot.vy *= 0.98;

          // Limit speed (slower for larger dots)
          const maxSpeed = dot.isBlack ? 25 : 3 / (dot.radius / 15);
          const speed = Math.sqrt(dot.vx * dot.vx + dot.vy * dot.vy);
          if (speed > maxSpeed) {
            dot.vx = (dot.vx / speed) * maxSpeed;
            dot.vy = (dot.vy / speed) * maxSpeed;
          }

          // Move
          dot.x += dot.vx;
          dot.y += dot.vy;

          // Bounce off walls
          if (dot.x - dot.radius < 0) {
            dot.x = dot.radius;
            dot.vx *= -0.8;
          }
          if (dot.x + dot.radius > width) {
            dot.x = width - dot.radius;
            dot.vx *= -0.8;
          }
          if (dot.y - dot.radius < 0) {
            dot.y = dot.radius;
            dot.vy *= -0.8;
          }
          if (dot.y + dot.radius > height) {
            dot.y = height - dot.radius;
            dot.vy *= -0.8;
          }
        }

        // Check for same-color clustering
        checkClusterCollisions();

        // Check for black dot attacks
        checkBlackDotAttacks();

        // Check lose condition
        checkClusterLoseCondition();
      }

      function checkClusterCollisions() {
        const toMerge = []; // pairs of dots to merge

        for (let i = 0; i < clusterDots.length; i++) {
          const a = clusterDots[i];
          if (a.isBlack) continue;

          for (let j = i + 1; j < clusterDots.length; j++) {
            const b = clusterDots[j];
            if (b.isBlack || a.color !== b.color) continue;
            if (a.radius !== b.radius) continue; // Only same-size can cluster

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = a.radius + b.radius;

            if (dist < minDist * 0.9) {
              toMerge.push([a, b]);
            }
          }
        }

        // Process merges
        for (const [a, b] of toMerge) {
          if (!clusterDots.includes(a) || !clusterDots.includes(b)) continue;

          // Find all same-color, same-size dots touching this cluster
          const cluster = [a, b];
          let changed = true;
          while (changed) {
            changed = false;
            for (const dot of clusterDots) {
              if (cluster.includes(dot) || dot.isBlack) continue;
              if (dot.color !== a.color || dot.radius !== a.radius) continue;

              for (const c of cluster) {
                const dx = dot.x - c.x;
                const dy = dot.y - c.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < (dot.radius + c.radius) * 0.95) {
                  cluster.push(dot);
                  changed = true;
                  break;
                }
              }
            }
          }

          // If we have 4+ dots, merge into larger dot
          if (cluster.length >= CLUSTER_MERGE_SIZE) {
            const avgX = cluster.reduce((s, d) => s + d.x, 0) / cluster.length;
            const avgY = cluster.reduce((s, d) => s + d.y, 0) / cluster.length;

            // Remove clustered dots
            for (const dot of cluster) {
              const idx = clusterDots.indexOf(dot);
              if (idx !== -1) clusterDots.splice(idx, 1);
            }

            // Create larger dot
            const newRadius = a.radius * 2;
            clusterDots.push({
              id: clusterNextId++,
              x: avgX,
              y: avgY,
              vx: 0,
              vy: 0,
              radius: newRadius,
              color: a.color,
              isBlack: false,
              clusterId: null,
              hitsTaken: 0,
            });
          }
        }
      }

      function checkBlackDotAttacks() {
        const blackDots = clusterDots.filter((d) => d.isBlack);
        const coloredDots = clusterDots.filter((d) => !d.isBlack);

        for (const black of blackDots) {
          // Only deal damage if black dot is moving (thrown, not dragged)
          const blackSpeed = Math.sqrt(
            black.vx * black.vx + black.vy * black.vy,
          );
          if (blackSpeed < 2) continue; // Must be moving to attack

          for (const colored of coloredDots) {
            const dx = colored.x - black.x;
            const dy = colored.y - black.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = black.radius + colored.radius;

            if (dist < minDist * 0.9) {
              // Calculate hits needed: same size = 1, 2x size = 4, 4x size = 16
              const sizeRatio = colored.radius / black.radius;
              const hitsNeeded =
                sizeRatio <= 1 ? 1 : Math.round(sizeRatio * sizeRatio);

              colored.hitsTaken++;

              // Bounce black dot back (reverse velocity)
              const nx = dx / dist;
              const ny = dy / dist;
              black.x = colored.x - nx * (minDist + 5);
              black.y = colored.y - ny * (minDist + 5);
              black.vx = -black.vx * 0.5;
              black.vy = -black.vy * 0.5;

              if (colored.hitsTaken >= hitsNeeded) {
                // Destroy colored dot (just remove it)
                const idx = clusterDots.indexOf(colored);
                if (idx !== -1) clusterDots.splice(idx, 1);
              }
              break; // One collision per black dot per frame
            }
          }
        }
      }

      function mergeBlackDots(a, b) {
        if (!clusterDots.includes(a) || !clusterDots.includes(b)) return;

        const avgX = (a.x + b.x) / 2;
        const avgY = (a.y + b.y) / 2;
        const newRadius = Math.sqrt(a.radius * a.radius + b.radius * b.radius);

        // Remove both dots
        const idxA = clusterDots.indexOf(a);
        if (idxA !== -1) clusterDots.splice(idxA, 1);
        const idxB = clusterDots.indexOf(b);
        if (idxB !== -1) clusterDots.splice(idxB, 1);

        // Create merged dot
        clusterDots.push({
          id: clusterNextId++,
          x: avgX,
          y: avgY,
          vx: 0,
          vy: 0,
          radius: newRadius,
          color: "#222222",
          isBlack: true,
          clusterId: null,
          hitsTaken: 0,
        });
      }

      function checkClusterLoseCondition() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const totalArea = width * height;

        // Calculate total area of colored dots
        let coloredArea = 0;
        let maxRadius = 0;
        for (const dot of clusterDots) {
          if (!dot.isBlack) {
            coloredArea += Math.PI * dot.radius * dot.radius;
            maxRadius = Math.max(maxRadius, dot.radius);
          }
        }

        const coverage = coloredArea / totalArea;

        // Show warning when coverage is high
        const warning = document.getElementById("clusterWarning");
        const warningText = document.getElementById("clusterWarningText");
        const timerDisplay = document.getElementById("clusterTimerMain");
        if (coverage > 0.3) {
          warning.classList.add("visible");
          if (warningText) warningText.style.display = "block";
          if (timerDisplay) timerDisplay.classList.add("cluster-danger");
        } else {
          warning.classList.remove("visible");
          if (warningText) warningText.style.display = "none";
          if (timerDisplay) timerDisplay.classList.remove("cluster-danger");
        }

        // Lose if coverage too high or a dot is too big
        if (coverage > 0.5 || maxRadius > Math.min(width, height) * 0.3) {
          endClusterRound();
        }
      }

      function renderClusterDots() {
        // All rendering and hit detection is now handled by Canvas
        renderCanvas();
      }

      function darkenColor(color) {
        // Simple color darkening for stroke
        const colors = {
          "#ff4444": "#cc0000",
          "#ffcc00": "#cc9900",
          "#4444ff": "#0000cc",
          "#44cc44": "#009900",
          "#222222": "#000000",
          "#ffffff": "#cccccc",
        };
        return colors[color] || color;
      }

      function clusterTick() {
        clusterTimeElapsed++;

        // Increase spawn rate over time
        if (clusterTimeElapsed % 10 === 0 && clusterSpawnInterval > 500) {
          clusterSpawnInterval = Math.max(500, clusterSpawnInterval - 100);
        }

        updateClusterHUD();
      }

      function formatClusterTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins + ":" + (secs < 10 ? "0" : "") + secs;
      }

      function updateClusterHUD() {
        const timerValue = document.getElementById("clusterTimerValue");
        const bestLabel = document.getElementById("clusterBestLabel");

        if (!timerValue) return;

        timerValue.textContent = formatClusterTime(clusterTimeElapsed);
        bestLabel.textContent = "Best: " + formatClusterTime(clusterBest);
      }

      // ========== CANVAS RENDER ==========
      function renderCanvas() {
        const theme = themes[currentTheme];
        const width = gameCanvas.width;
        const height = gameCanvas.height;

        // Clear and draw background
        ctx.fillStyle = theme.background;
        ctx.fillRect(0, 0, width, height);

        // Draw grid if visible
        if (showGrid) {
          ctx.strokeStyle = "rgba(0,0,0,0.2)";
          ctx.lineWidth = 0.5;
          for (let x = 0; x <= width; x += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }
          for (let y = 0; y <= height; y += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }
        }

        // Draw golf target if in golf mode
        if (golfMode && golfTarget) {
          // Outer ring with dashed stroke
          ctx.setLineDash([10, 5]);
          ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(golfTarget.x, golfTarget.y, golfTarget.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.setLineDash([]);

          // Inner ring
          ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(golfTarget.x, golfTarget.y, golfTarget.radius * 0.5, 0, Math.PI * 2);
          ctx.stroke();

          // Center dot
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(golfTarget.x, golfTarget.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }

        // Draw pinball bumpers
        if (pinballMode) {
          for (const bumper of pinballBumpers) {
            const isBonus = bumper.type === "bonus";

            // Outer glow
            ctx.strokeStyle = isBonus ? "rgba(255, 215, 0, 0.5)" : "rgba(255, 255, 255, 0.3)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(bumper.x, bumper.y, bumper.radius + 5, 0, Math.PI * 2);
            ctx.stroke();

            // Main bumper circle
            ctx.fillStyle = isBonus ? "#ffd700" : "#fff";
            ctx.strokeStyle = isBonus ? "#b8860b" : "#ccc";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Point value text
            ctx.fillStyle = isBonus ? "#000" : "#333";
            ctx.font = "bold 12px 'JetBrains Mono', monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(bumper.points.toString(), bumper.x, bumper.y);
          }
        }

        // Draw cluster dots
        if (clusterMode) {
          for (const dot of clusterDots) {
            // Draw glow effect for large colored dots
            if (!dot.isBlack && dot.radius > 15) {
              ctx.shadowColor = dot.color;
              ctx.shadowBlur = 8;
            }

            ctx.fillStyle = dot.color;
            ctx.strokeStyle = dot.isBlack ? "#000" : darkenColor(dot.color);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Reset shadow
            ctx.shadowBlur = 0;

            // Draw hit indicator for colored dots being attacked
            if (!dot.isBlack && dot.hitsTaken > 0) {
              ctx.fillStyle = "#fff";
              ctx.font = "bold 12px 'JetBrains Mono', monospace";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(dot.hitsTaken.toString(), dot.x, dot.y);
            }
          }
        }

        // Draw main dots
        for (const dot of dots) {
          const fillColor = dot.color || theme.dotFill;
          let strokeColor = theme.dotStroke;
          let strokeWidth = STROKE_WIDTH;

          if (dot.isSun) {
            strokeColor = "#FF8C00";
            strokeWidth = 4;
          } else if (dot.locked) {
            strokeColor = "#ffc107";
            strokeWidth = 3;
          }

          ctx.fillStyle = fillColor;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
      }

      // ========== RENDER ==========
      function render() {
        renderCanvas();
      }

      // ========== DOT CREATION ==========
      function createDot(x, y) {
        // Disable dot creation in game modes
        if (golfMode || pinballMode || clusterMode) return;

        const count = parseInt(
          document.getElementById("countSlider").value,
          10,
        );

        if (count === 1) {
          const placement = findPlacementPosition(x, y, DEFAULT_RADIUS);
          if (!wouldOverlap(placement.x, placement.y, DEFAULT_RADIUS)) {
            const newDot = {
              id: nextId++,
              x: placement.x,
              y: placement.y,
              radius: DEFAULT_RADIUS,
            };
            dots.push(newDot);

            // If in orbit mode, add to orbiting dots so they start orbiting
            if (orbitMode && orbitSunId !== null && orbitingDots.size < MAX_ORBITERS) {
              dotVelocities.set(newDot.id, { vx: 0, vy: 0 });
              orbitingDots.add(newDot.id);
            }
          }
        } else {
          createDotCluster(x, y, count);
        }
        render();
      }

      function createDotCluster(centerX, centerY, count) {
        const diameter = DEFAULT_RADIUS * 2;
        const centerPlacement = findPlacementPosition(
          centerX,
          centerY,
          DEFAULT_RADIUS,
        );
        if (
          wouldOverlap(centerPlacement.x, centerPlacement.y, DEFAULT_RADIUS)
        ) {
          return;
        }

        const centerDot = {
          id: nextId++,
          x: centerPlacement.x,
          y: centerPlacement.y,
          radius: DEFAULT_RADIUS,
        };
        dots.push(centerDot);

        // Add to orbiting dots if in orbit mode
        if (orbitMode && orbitSunId !== null && orbitingDots.size < MAX_ORBITERS) {
          dotVelocities.set(centerDot.id, { vx: 0, vy: 0 });
          orbitingDots.add(centerDot.id);
        }

        if (count === 1) return;

        let placed = 1;
        let ring = 1;
        let angleOffset = Math.random() * Math.PI * 2;

        while (placed < count) {
          const dotsInRing = ring === 1 ? 6 : ring * 6;
          const angleStep = (Math.PI * 2) / dotsInRing;

          for (let i = 0; i < dotsInRing && placed < count; i++) {
            const angle = angleOffset + i * angleStep;
            const distance = diameter * ring;

            const testX = centerPlacement.x + Math.cos(angle) * distance;
            const testY = centerPlacement.y + Math.sin(angle) * distance;

            const snapped = snapToGrid(testX, testY);

            if (!wouldOverlap(snapped.x, snapped.y, DEFAULT_RADIUS)) {
              const newDot = {
                id: nextId++,
                x: snapped.x,
                y: snapped.y,
                radius: DEFAULT_RADIUS,
              };
              dots.push(newDot);

              // Add to orbiting dots if in orbit mode
              if (orbitMode && orbitSunId !== null && orbitingDots.size < MAX_ORBITERS) {
                dotVelocities.set(newDot.id, { vx: 0, vy: 0 });
                orbitingDots.add(newDot.id);
              }

              placed++;
            }
          }
          ring++;
          if (ring > 5) break;
        }
      }

      // ========== GROW / SHRINK WITH ANIMATION ==========
      const SIZE_ANIMATION_DURATION = 150; // ms
      const activeAnimations = new Map(); // dotId -> {startRadius, targetRadius, startTime, startX, startY, targetX, targetY}

      function easeOutBack(t) {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
      }

      function animateDotRadius(id, targetRadius, targetX = null, targetY = null) {
        const dot = dots.find((d) => d.id === id);
        if (!dot) return;

        activeAnimations.set(id, {
          startRadius: dot.radius,
          targetRadius: targetRadius,
          startTime: performance.now(),
          startX: dot.x,
          startY: dot.y,
          targetX: targetX !== null ? targetX : dot.x,
          targetY: targetY !== null ? targetY : dot.y
        });

        startAnimationLoop();
      }

      let animationLoopId = null;
      function startAnimationLoop() {
        if (animationLoopId) return;
        animationLoopId = requestAnimationFrame(updateAnimations);
      }

      function updateAnimations(timestamp) {
        let hasActiveAnimations = false;

        for (const [id, anim] of activeAnimations) {
          const dot = dots.find((d) => d.id === id);
          if (!dot) {
            activeAnimations.delete(id);
            continue;
          }

          const elapsed = timestamp - anim.startTime;
          const progress = Math.min(elapsed / SIZE_ANIMATION_DURATION, 1);
          const eased = easeOutBack(progress);

          // Clamp radius to prevent negative values from easing overshoot
          dot.radius = Math.max(0.1, anim.startRadius + (anim.targetRadius - anim.startRadius) * eased);
          dot.x = anim.startX + (anim.targetX - anim.startX) * eased;
          dot.y = anim.startY + (anim.targetY - anim.startY) * eased;

          if (progress >= 1) {
            activeAnimations.delete(id);
            if (anim.removeOnComplete) {
              // Remove the dot completely
              dots = dots.filter((d) => d.id !== id);
              dotVelocities.delete(id);
              noFrictionDots.delete(id);
              boostedDots.delete(id);
            } else {
              dot.radius = anim.targetRadius;
              dot.x = anim.targetX;
              dot.y = anim.targetY;
            }
          } else {
            hasActiveAnimations = true;
          }
        }

        render();

        if (hasActiveAnimations) {
          animationLoopId = requestAnimationFrame(updateAnimations);
        } else {
          animationLoopId = null;
        }
      }

      function growDot(id) {
        const dot = dots.find((d) => d.id === id);
        if (!dot) return;

        const newRadius = Math.min(dot.radius * 2, MAX_RADIUS);
        const radiusIncrease = newRadius - dot.radius;

        if (!wouldOverlap(dot.x, dot.y, newRadius, id)) {
          animateDotRadius(id, newRadius);
          return;
        }

        // Find dots that would overlap and shift away
        const overlappingDots = dots.filter((other) => {
          if (other.id === id) return false;
          const dx = other.x - dot.x;
          const dy = other.y - dot.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < newRadius + other.radius;
        });

        if (overlappingDots.length === 0) return;

        let shiftX = 0,
          shiftY = 0;
        for (const other of overlappingDots) {
          const dx = dot.x - other.x;
          const dy = dot.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            shiftX += dx / dist;
            shiftY += dy / dist;
          }
        }

        const shiftMag = Math.sqrt(shiftX * shiftX + shiftY * shiftY);
        if (shiftMag === 0) return;
        shiftX /= shiftMag;
        shiftY /= shiftMag;

        const newX = dot.x + shiftX * radiusIncrease;
        const newY = dot.y + shiftY * radiusIncrease;

        if (!wouldOverlap(newX, newY, newRadius, id)) {
          animateDotRadius(id, newRadius, newX, newY);
        }
      }

      function shrinkDot(id) {
        const dot = dots.find((d) => d.id === id);
        if (!dot) return;

        const newRadius = dot.radius / 2;
        if (newRadius < MIN_RADIUS) {
          // Animate shrink to zero then remove
          activeAnimations.set(id, {
            startRadius: dot.radius,
            targetRadius: 0,
            startTime: performance.now(),
            startX: dot.x,
            startY: dot.y,
            targetX: dot.x,
            targetY: dot.y,
            removeOnComplete: true
          });
          startAnimationLoop();
        } else {
          animateDotRadius(id, newRadius);
        }
      }

      // ========== HOLD TIMER ==========
      function clearHoldTimer() {
        if (holdTimer) {
          clearTimeout(holdTimer);
          holdTimer = null;
        }
        holdDotId = null;
      }

      // ========== DOT EVENT HANDLERS ==========
      // ========== DRAG FINALIZATION ==========
      function finalizeDrag() {
        if (isDragging && dragDotId !== null) {
          // On release, just let physics continue - don't switch modes
          // The dot already has velocity from steering
          const vel = dotVelocities.get(dragDotId);
          if (vel) {
            // Apply boost multiplier to throw velocity if boost is active
            if (isBoostKeyHeld) {
              vel.vx *= BOOST_MULTIPLIER;
              vel.vy *= BOOST_MULTIPLIER;
              boostedDots.add(dragDotId);
            }

            // Chain Reaction: auto-boost and start round on next throw
            if (chainWaitingForThrow) {
              if (!isBoostKeyHeld) {
                vel.vx *= BOOST_MULTIPLIER;
                vel.vy *= BOOST_MULTIPLIER;
                boostedDots.add(dragDotId);
              }
              chainWaitingForThrow = false;
              startChainReactionRound(dragDotId);
              document.getElementById("chainStartBtn").textContent =
                "Start Chain";
            }

            // Golf: count strokes when ball is thrown
            if (
              golfMode &&
              golfBallId !== null &&
              dragDotId === golfBallId &&
              !golfHoleComplete
            ) {
              golfStrokes++;
              updateGolfHUD();
            }

            // Pinball: activate round on first throw
            if (
              pinballMode &&
              pinballBallId !== null &&
              dragDotId === pinballBallId &&
              !pinballRoundActive
            ) {
              pinballRoundActive = true;
              document.getElementById("pinballStartBtn").style.display = "none";
            }

            const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
            if (speed < MIN_VELOCITY) {
              // If barely moving, snap to grid and stop
              const dot = dots.find((d) => d.id === dragDotId);
              if (dot) {
                const snapped = snapToGrid(dot.x, dot.y);
                if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                  dot.x = snapped.x;
                  dot.y = snapped.y;
                }
              }
              dotVelocities.delete(dragDotId);
              noFrictionDots.delete(dragDotId);
              boostedDots.delete(dragDotId);
              render();
            } else if (isNoFrictionKeyHeld) {
              // Mark this dot as no-friction (perpetual motion)
              noFrictionDots.add(dragDotId);
            }
          }
        } else if (dragDotId !== null) {
          // Wasn't dragging, remove velocity if stationary
          const vel = dotVelocities.get(dragDotId);
          if (
            vel &&
            Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy) < MIN_VELOCITY
          ) {
            dotVelocities.delete(dragDotId);
          }
        }

        isDragging = false;
        dragDotId = null;
        dragStartPos = null;
        dragOriginalPos = null;
        dragTargetPos = null;
        velocityHistory = [];
        gameCanvas.classList.remove("dragging");
      }

      function finalizeClusterDrag() {
        if (clusterDragDotId !== null) {
          const draggedDot = clusterDots.find((d) => d.id === clusterDragDotId);
          if (draggedDot && draggedDot.isBlack) {
            // Apply throw velocity (with boost)
            const throwMultiplier = 8;
            draggedDot.vx = clusterDragVelocity.vx * throwMultiplier;
            draggedDot.vy = clusterDragVelocity.vy * throwMultiplier;

            // Check if we should merge with another black dot (if barely moving)
            const speed = Math.sqrt(
              draggedDot.vx * draggedDot.vx + draggedDot.vy * draggedDot.vy,
            );
            if (speed < 1) {
              for (const other of clusterDots) {
                if (other.id === clusterDragDotId || !other.isBlack) continue;

                const dx = other.x - draggedDot.x;
                const dy = other.y - draggedDot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = draggedDot.radius + other.radius;

                if (dist < minDist * 0.8) {
                  // Merge the two black dots
                  mergeBlackDots(draggedDot, other);
                  break;
                }
              }
            }
          }
        }

        clusterDragDotId = null;
        clusterDragStartPos = null;
        clusterDragOriginalPos = null;
        clusterDragLastPos = null;
        clusterDragVelocity = { vx: 0, vy: 0 };
        gameCanvas.classList.remove("dragging");
      }

      // ========== UNIFIED PHYSICS LOOP ==========
      function physicsLoop() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Step 1: Apply drag steering (if dragging)
        if (isDragging && dragDotId !== null && dragTargetPos) {
          const dragDot = dots.find((d) => d.id === dragDotId);
          if (dragDot) {
            let vel = dotVelocities.get(dragDotId);
            if (!vel) {
              vel = { vx: 0, vy: 0 };
              dotVelocities.set(dragDotId, vel);
            }

            // Weight-based responsiveness (boosted when A key is held)
            const weight = mass(dragDot);
            const baseResponsiveness = Math.min(1, 0.3 / Math.sqrt(weight));
            const responsiveness = isBoostKeyHeld
              ? Math.min(1, baseResponsiveness * BOOST_MULTIPLIER)
              : baseResponsiveness;

            // Steering: compute desired velocity toward target
            const toTargetX = dragTargetPos.x - dragDot.x;
            const toTargetY = dragTargetPos.y - dragDot.y;

            // The velocity IS the movement toward target (weighted)
            vel.vx = toTargetX * responsiveness;
            vel.vy = toTargetY * responsiveness;
          }
        }

        // Step 1.5: Apply orbital mechanics (dots orbit around sun like moon around earth)
        // Only applies to dots already in orbitingDots set (added when created or thrown)
        if (orbitMode && orbitSunId !== null && !isFrozen) {
          const sun = dots.find(d => d.id === orbitSunId);
          if (sun) {
            const strength = getOrbitStrength();

            // Only process dots that are already orbiting
            for (const dotId of orbitingDots) {
              const dot = dots.find(d => d.id === dotId);
              if (!dot || dot.locked) {
                orbitingDots.delete(dotId);
                continue;
              }

              const dx = dot.x - sun.x;
              const dy = dot.y - sun.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              const maxRange = 500;
              if (dist > maxRange) {
                orbitingDots.delete(dotId);
                continue;
              }

              // Minimum orbital distance - keep dots away from sun
              const minOrbitDist = sun.radius + dot.radius + 30;

              // Remove friction for orbiting dots so they maintain speed
              noFrictionDots.add(dot.id);

              // Get or create velocity
              let vel = dotVelocities.get(dot.id);
              if (!vel) {
                vel = { vx: 0, vy: 0 };
                dotVelocities.set(dot.id, vel);
              }

              // Calculate orbital radius (where the dot should orbit)
              const orbitRadius = Math.max(dist, minOrbitDist);

              // Angular velocity (radians per frame) - scales with strength, slower when further
              const angularVel = (0.02 + strength * 0.02) * (100 / orbitRadius);

              // Current angle from sun to dot
              const angle = Math.atan2(dy, dx);

              // New angle (rotate counter-clockwise)
              const newAngle = angle + angularVel;

              // Target position on orbit
              const targetX = sun.x + Math.cos(newAngle) * orbitRadius;
              const targetY = sun.y + Math.sin(newAngle) * orbitRadius;

              // Set velocity to move toward target position
              vel.vx = (targetX - dot.x) * 0.5;
              vel.vy = (targetY - dot.y) * 0.5;
            }
          }
        }

        // Step 2: Apply velocities to positions (only dragged dot if frozen, skip locked)
        for (const [dotId, vel] of dotVelocities) {
          if (isFrozen && dotId !== dragDotId) continue;

          const dot = dots.find((d) => d.id === dotId);
          if (!dot) {
            dotVelocities.delete(dotId);
            continue;
          }

          // Locked dots don't move
          if (dot.locked) {
            dotVelocities.delete(dotId);
            continue;
          }

          dot.x += vel.vx;
          dot.y += vel.vy;
        }

        // Step 3: Boundary collisions (only for dragged dot if frozen, skip locked)
        for (const [dotId, vel] of dotVelocities) {
          if (isFrozen && dotId !== dragDotId) continue;

          const dot = dots.find((d) => d.id === dotId);
          if (!dot || dot.locked) continue;

          if (dot.x - dot.radius < 0) {
            dot.x = dot.radius;
            if (!isFrozen) vel.vx *= -0.7;
          } else if (dot.x + dot.radius > width) {
            dot.x = width - dot.radius;
            if (!isFrozen) vel.vx *= -0.7;
          }

          if (dot.y - dot.radius < 0) {
            dot.y = dot.radius;
            if (!isFrozen) vel.vy *= -0.7;
          } else if (dot.y + dot.radius > height) {
            dot.y = height - dot.radius;
            if (!isFrozen) vel.vy *= -0.7;
          }
        }

        // Step 4: Collision resolution
        if (isFrozen) {
          // In freeze mode, only handle collisions for the dragged dot
          // Other dots act as immovable obstacles
          if (isDragging && dragDotId !== null) {
            const dragDot = dots.find((d) => d.id === dragDotId);
            if (dragDot) {
              for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {
                for (const otherDot of dots) {
                  if (otherDot.id === dragDotId) continue;

                  const dx = otherDot.x - dragDot.x;
                  const dy = otherDot.y - dragDot.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  const minDist = dragDot.radius + otherDot.radius;

                  if (dist < minDist && dist > 0) {
                    // Push dragged dot back (other dot is immovable)
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const overlap = minDist - dist;

                    dragDot.x -= nx * overlap;
                    dragDot.y -= ny * overlap;

                    // Also zero out velocity in that direction
                    const vel = dotVelocities.get(dragDotId);
                    if (vel) {
                      const velDotN = vel.vx * nx + vel.vy * ny;
                      if (velDotN > 0) {
                        vel.vx -= velDotN * nx;
                        vel.vy -= velDotN * ny;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          // Normal physics: full collision resolution
          for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {
            processedCollisions.clear();

            for (let i = 0; i < dots.length; i++) {
              const dotA = dots[i];
              const velA = dotVelocities.get(dotA.id) || { vx: 0, vy: 0 };

              for (let j = i + 1; j < dots.length; j++) {
                const dotB = dots[j];

                // Skip if neither dot is moving (optimization)
                const velB = dotVelocities.get(dotB.id) || { vx: 0, vy: 0 };
                const aMoving = dotVelocities.has(dotA.id);
                const bMoving = dotVelocities.has(dotB.id);
                if (!aMoving && !bMoving) continue;

                const collisionKey = dotA.id + "-" + dotB.id;
                if (processedCollisions.has(collisionKey)) continue;
                processedCollisions.add(collisionKey);

                // Ensure both have velocity entries for collision resolution
                if (!dotVelocities.has(dotA.id)) {
                  dotVelocities.set(dotA.id, { vx: 0, vy: 0 });
                }
                if (!dotVelocities.has(dotB.id)) {
                  dotVelocities.set(dotB.id, { vx: 0, vy: 0 });
                }

                const velARef = dotVelocities.get(dotA.id);
                const velBRef = dotVelocities.get(dotB.id);

                resolveCollision(dotA, dotB, velARef, velBRef);
              }
            }
          }
        }

        // Step 4.5: Pinball bumper collisions
        if (pinballMode && pinballRoundActive && pinballBallId !== null) {
          const ball = dots.find((d) => d.id === pinballBallId);
          if (ball) {
            const vel = dotVelocities.get(pinballBallId);
            if (vel) {
              for (const bumper of pinballBumpers) {
                const dx = ball.x - bumper.x;
                const dy = ball.y - bumper.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = ball.radius + bumper.radius;

                if (dist < minDist && dist > 0) {
                  // Bounce off bumper
                  const nx = dx / dist;
                  const ny = dy / dist;

                  // Push ball out
                  const overlap = minDist - dist;
                  ball.x += nx * overlap;
                  ball.y += ny * overlap;

                  // Reflect velocity with boost
                  const dot = vel.vx * nx + vel.vy * ny;
                  if (dot < 0) {
                    // Moving toward bumper
                    vel.vx -= 2 * dot * nx;
                    vel.vy -= 2 * dot * ny;

                    // Apply boost
                    vel.vx *= 1.3;
                    vel.vy *= 1.3;

                    // Score!
                    pinballScore += bumper.points;
                    updatePinballHUD();
                  }
                }
              }
            }
          }
        }

        // Step 5: Apply friction (skip if frozen, or for dragged/perpetual dots)
        if (!isFrozen) {
          for (const [dotId, vel] of dotVelocities) {
            if (dotId === dragDotId) continue; // Don't apply friction while dragging
            if (noFrictionDots.has(dotId)) continue; // Perpetual motion dots

            const dot = dots.find((d) => d.id === dotId);
            if (!dot) continue;

            // Mass-based friction: heavier dots have more inertia
            const m = mass(dot);
            const baseFriction = getFriction();
            const friction = 1 - (1 - baseFriction) / Math.sqrt(m);
            vel.vx *= friction;
            vel.vy *= friction;

            // Stop if velocity is very low
            const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
            if (speed < MIN_VELOCITY) {
              // Snap to grid
              const snapped = snapToGrid(dot.x, dot.y);
              if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                dot.x = snapped.x;
                dot.y = snapped.y;
              }
              dotVelocities.delete(dotId);

              // Golf: check if ball stopped in target
              if (golfMode && dotId === golfBallId && !golfHoleComplete) {
                checkGolfWin();
              }
            }
          }
        }

        // Step 6: Cluster mode physics
        if (clusterMode && clusterRoundActive) {
          updateClusterPhysics();
          renderClusterDots();
        }

        render();

        // Continue loop if any dots are moving OR dragging is active OR cluster mode active OR orbit mode with attractor
        if (
          dotVelocities.size > 0 ||
          isDragging ||
          (clusterMode && clusterRoundActive) ||
          (orbitMode && orbitSunId !== null)
        ) {
          physicsAnimationId = requestAnimationFrame(physicsLoop);
        } else {
          physicsAnimationId = null;

          // Chain Reaction: end round when all motion stops
          if (chainReactionMode && chainReactionActive) {
            endChainReactionRound();
          }

          // Pinball: end round when all motion stops
          if (pinballMode && pinballRoundActive) {
            endPinballRound();
          }
        }
      }

      function startPhysicsLoop() {
        if (!physicsAnimationId) {
          physicsAnimationId = requestAnimationFrame(physicsLoop);
        }
      }

      // ========== BACKGROUND HANDLERS ==========
      // ========== UI CONTROLS ==========

      // Controls panel toggle
      const controlsToggle = document.getElementById("controlsToggle");
      const controlsPanel = document.getElementById("controlsPanel");
      controlsToggle.addEventListener("click", () => {
        controlsPanel.classList.toggle("open");
      });

      // Dot count slider
      const countSlider = document.getElementById("countSlider");
      const countValue = document.getElementById("countValue");
      countSlider.addEventListener("input", () => {
        countValue.textContent = countSlider.value;
      });

      // Modifier toggles (work alongside keyboard)
      const boostToggle = document.getElementById("boostToggle");
      const perpetualToggle = document.getElementById("perpetualToggle");

      boostToggle.addEventListener("click", () => {
        isBoostKeyHeld = !isBoostKeyHeld;
        boostToggle.classList.toggle("active", isBoostKeyHeld);
        boostIndicator.classList.toggle("active", isBoostKeyHeld);
      });

      perpetualToggle.addEventListener("click", () => {
        isNoFrictionKeyHeld = !isNoFrictionKeyHeld;
        perpetualToggle.classList.toggle("active", isNoFrictionKeyHeld);
        perpetualIndicator.classList.toggle("active", isNoFrictionKeyHeld);
      });

      // Physics sliders
      const frictionSlider = document.getElementById("frictionSlider");
      const frictionValue = document.getElementById("frictionValue");
      frictionSlider.addEventListener("input", () => {
        frictionValue.textContent = frictionSlider.value;
      });

      const bounceSlider = document.getElementById("bounceSlider");
      const bounceValue = document.getElementById("bounceValue");
      bounceSlider.addEventListener("input", () => {
        bounceValue.textContent = bounceSlider.value;
      });

      // Helper to get current physics values
      function getFriction() {
        return parseFloat(frictionSlider.value) / 100;
      }

      function getRestitution() {
        return parseFloat(bounceSlider.value) / 100;
      }

      // Freeze toggle
      const freezeToggle = document.getElementById("freezeToggle");
      const freezeIndicator = document.getElementById("freezeIndicator");
      freezeToggle.addEventListener("change", () => {
        isFrozen = freezeToggle.checked;
        freezeIndicator.classList.toggle("active", isFrozen);
        if (isFrozen) {
          // Stop all dots when freezing
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();
        }
      });

      // Click freeze indicator to exit freeze mode
      freezeIndicator.addEventListener("click", () => {
        if (isFrozen) {
          isFrozen = false;
          freezeToggle.checked = false;
          freezeIndicator.classList.remove("active");
        }
      });

      // Orbit mode toggle
      const orbitToggle = document.getElementById("orbitToggle");

      const orbitStrengthRow = document.getElementById("orbitStrengthRow");
      const orbitStrengthSlider = document.getElementById("orbitStrength");
      const orbitStrengthValue = document.getElementById("orbitStrengthValue");
      const orbitHint = document.getElementById("orbitHint");

      orbitStrengthSlider.addEventListener("input", () => {
        orbitStrengthValue.textContent = orbitStrengthSlider.value;
      });

      function getOrbitStrength() {
        return parseFloat(orbitStrengthSlider.value) / 50; // 50 = 1x, 100 = 2x
      }

      function enableOrbitMode() {
        orbitMode = true;
        orbitToggle.checked = true;
        orbitStrengthRow.style.display = "flex";
        orbitHint.style.display = orbitSunId === null ? "block" : "none";

        // Exit other modes
        if (paintMode) {
          paintMode = false;
          paintModeToggle.classList.remove("active");
          paintIndicator.classList.remove("active");
        }
        if (lockMode) {
          lockMode = false;
          lockModeToggle.classList.remove("active");
          lockIndicator.classList.remove("active");
        }
      }

      function disableOrbitMode() {
        orbitMode = false;
        orbitToggle.checked = false;
        orbitStrengthRow.style.display = "none";
        orbitHint.style.display = "none";

        // Restore the sun to a normal dot
        if (orbitSunId !== null) {
          const sun = dots.find(d => d.id === orbitSunId);
          if (sun) {
            sun.isSun = false;
            sun.locked = false; // Unlock it so it can move again
          }
          orbitSunId = null;
          orbitingDots.clear();
          render();
        }
      }

      function setOrbitAttractor(dot) {
        // Unmark previous sun
        if (orbitSunId !== null) {
          const oldSun = dots.find(d => d.id === orbitSunId);
          if (oldSun) {
            oldSun.isSun = false;
          }
        }

        // Mark new sun
        dot.isSun = true;
        dot.locked = true; // Lock it so it doesn't move
        orbitSunId = dot.id;
        orbitingDots.clear();
        orbitHint.style.display = "none";

        // Stop any velocity
        dotVelocities.delete(dot.id);
        noFrictionDots.delete(dot.id);
        boostedDots.delete(dot.id);

        render();

        // Start physics loop so gravity runs continuously
        startPhysicsLoop();
      }

      orbitToggle.addEventListener("change", () => {
        if (orbitToggle.checked) {
          enableOrbitMode();
        } else {
          disableOrbitMode();
        }
      });

      // Paint mode controls
      const paintModeToggle = document.getElementById("paintModeToggle");
      const paintIndicator = document.getElementById("paintIndicator");
      const paintColorPreview = document.getElementById("paintColorPreview");
      const paintSwatches = document.querySelectorAll(".paint-swatch");

      function togglePaintMode() {
        if (!selectedPaintColor) {
          // Default to first color if none selected
          selectedPaintColor = "#ff6b6b";
          paintSwatches.forEach(s => s.classList.remove("selected"));
          document.querySelector('.paint-swatch[data-color="#ff6b6b"]').classList.add("selected");
        }
        paintMode = !paintMode;
        paintModeToggle.classList.toggle("active", paintMode);
        paintIndicator.classList.toggle("active", paintMode);

        if (paintMode) {
          // Freeze all dots when entering paint mode
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();
          paintColorPreview.style.background = selectedPaintColor === "reset"
            ? "linear-gradient(135deg, #666 25%, #999 25%, #999 50%, #666 50%, #666 75%, #999 75%)"
            : selectedPaintColor;
          // Exit lock mode if active
          if (lockMode) {
            lockMode = false;
            lockModeToggle.classList.remove("active");
            lockIndicator.classList.remove("active");
          }
        }
      }

      paintModeToggle.addEventListener("click", togglePaintMode);

      // Paint swatch selection
      paintSwatches.forEach(swatch => {
        swatch.addEventListener("click", () => {
          paintSwatches.forEach(s => s.classList.remove("selected"));
          swatch.classList.add("selected");
          selectedPaintColor = swatch.dataset.color;

          if (paintMode) {
            paintColorPreview.style.background = selectedPaintColor === "reset"
              ? "linear-gradient(135deg, #666 25%, #999 25%, #999 50%, #666 50%, #666 75%, #999 75%)"
              : selectedPaintColor;
          }
        });
      });

      // Click paint indicator to exit paint mode
      paintIndicator.addEventListener("click", () => {
        if (paintMode) {
          paintMode = false;
          paintModeToggle.classList.remove("active");
          paintIndicator.classList.remove("active");
        }
      });

      // Lock mode controls
      const lockModeToggle = document.getElementById("lockModeToggle");
      const lockIndicator = document.getElementById("lockIndicator");

      function toggleLockMode() {
        lockMode = !lockMode;
        lockModeToggle.classList.toggle("active", lockMode);
        lockIndicator.classList.toggle("active", lockMode);

        if (lockMode) {
          // Freeze all dots when entering lock mode
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();
          // Exit paint mode if active
          if (paintMode) {
            paintMode = false;
            paintModeToggle.classList.remove("active");
            paintIndicator.classList.remove("active");
          }
        }
      }

      lockModeToggle.addEventListener("click", toggleLockMode);

      // Click lock indicator to exit lock mode
      lockIndicator.addEventListener("click", () => {
        if (lockMode) {
          lockMode = false;
          lockModeToggle.classList.remove("active");
          lockIndicator.classList.remove("active");
        }
      });

      // Chain Reaction controls
      const chainReactionToggle = document.getElementById(
        "chainReactionToggle",
      );
      const chainThresholdRow = document.getElementById("chainThresholdRow");
      const chainThresholdSlider = document.getElementById(
        "chainThresholdSlider",
      );
      const chainThresholdValue = document.getElementById(
        "chainThresholdValue",
      );
      const chainStartBtn = document.getElementById("chainStartBtn");
      const chainResetBtn = document.getElementById("chainResetBtn");
      const chainScoreHUD = document.getElementById("chainScoreHUD");

      chainReactionToggle.addEventListener("change", () => {
        chainReactionMode = chainReactionToggle.checked;
        chainScoreHUD.classList.toggle("active", chainReactionMode);
        chainThresholdRow.style.display = chainReactionMode ? "flex" : "none";
        chainStartBtn.style.display = chainReactionMode ? "block" : "none";
        chainResetBtn.style.display = chainReactionMode ? "block" : "none";

        if (chainReactionMode) {
          // Disable other game modes
          const golfToggleEl = document.getElementById("golfToggle");
          if (golfToggleEl.checked) {
            golfToggleEl.checked = false;
            golfToggleEl.dispatchEvent(new Event("change"));
          }
          const pinballToggleEl = document.getElementById("pinballToggle");
          if (pinballToggleEl.checked) {
            pinballToggleEl.checked = false;
            pinballToggleEl.dispatchEvent(new Event("change"));
          }
          const clusterToggleEl = document.getElementById("clusterToggle");
          if (clusterToggleEl.checked) {
            clusterToggleEl.checked = false;
            clusterToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          chainReactionActive = false;
          chainReactionScore = 0;
          chainReactionStartDotId = null;
          chainWaitingForThrow = false;
        }
      });

      chainThresholdSlider.addEventListener("input", () => {
        chainThresholdValue.textContent = chainThresholdSlider.value;
      });

      chainStartBtn.addEventListener("click", () => {
        if (chainReactionActive) return;
        chainWaitingForThrow = true;
        chainStartBtn.textContent = "Throw a dot!";
      });

      chainResetBtn.addEventListener("click", () => {
        chainWaitingForThrow = false;
        chainStartBtn.textContent = "Start Chain";
        resetChainReaction();
      });

      // Golf mode
      const golfToggle = document.getElementById("golfToggle");
      const golfStartBtn = document.getElementById("golfStartBtn");
      const golfNextBtn = document.getElementById("golfNextBtn");
      const golfHUD = document.getElementById("golfHUD");

      golfToggle.addEventListener("change", () => {
        golfMode = golfToggle.checked;
        golfHUD.classList.toggle("active", golfMode);
        golfStartBtn.style.display = golfMode ? "block" : "none";

        if (golfMode) {
          // Disable other game modes
          if (chainReactionToggle.checked) {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          }
          const pinballToggleEl = document.getElementById("pinballToggle");
          if (pinballToggleEl.checked) {
            pinballToggleEl.checked = false;
            pinballToggleEl.dispatchEvent(new Event("change"));
          }
          const clusterToggleEl = document.getElementById("clusterToggle");
          if (clusterToggleEl.checked) {
            clusterToggleEl.checked = false;
            clusterToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          resetGolf();
          golfNextBtn.style.display = "none";
        }
      });

      golfStartBtn.addEventListener("click", () => {
        if (!golfHoleComplete && golfBallId !== null) return; // Already playing
        startGolfHole();
        golfStartBtn.style.display = "none";
      });

      golfNextBtn.addEventListener("click", () => {
        nextGolfHole();
        golfNextBtn.style.display = "none";
      });

      // Pinball mode
      const pinballToggle = document.getElementById("pinballToggle");
      const pinballStartBtn = document.getElementById("pinballStartBtn");
      const pinballHUD = document.getElementById("pinballHUD");

      pinballToggle.addEventListener("change", () => {
        pinballMode = pinballToggle.checked;
        pinballHUD.classList.toggle("active", pinballMode);
        pinballStartBtn.style.display = pinballMode ? "block" : "none";

        if (pinballMode) {
          // Disable other game modes
          if (chainReactionToggle.checked) {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          }
          if (golfToggle.checked) {
            golfToggle.checked = false;
            golfToggle.dispatchEvent(new Event("change"));
          }
          const clusterToggleEl = document.getElementById("clusterToggle");
          if (clusterToggleEl.checked) {
            clusterToggleEl.checked = false;
            clusterToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          resetPinball();
        }
      });

      pinballStartBtn.addEventListener("click", () => {
        startPinballRound();
      });

      // Cluster mode
      const clusterToggle = document.getElementById("clusterToggle");
      const clusterStartBtn = document.getElementById("clusterStartBtn");
      const clusterHUD = document.getElementById("clusterHUD");

      clusterToggle.addEventListener("change", () => {
        clusterMode = clusterToggle.checked;
        clusterHUD.classList.toggle("active", clusterMode);
        clusterStartBtn.style.display = clusterMode ? "block" : "none";

        if (clusterMode) {
          // Disable other game modes
          if (chainReactionToggle.checked) {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          }
          if (golfToggle.checked) {
            golfToggle.checked = false;
            golfToggle.dispatchEvent(new Event("change"));
          }
          const pinballToggleEl = document.getElementById("pinballToggle");
          if (pinballToggleEl.checked) {
            pinballToggleEl.checked = false;
            pinballToggleEl.dispatchEvent(new Event("change"));
          }
        } else {
          resetCluster();
        }
      });

      clusterStartBtn.addEventListener("click", () => {
        startClusterRound();
      });

      // Grid toggle
      const gridToggle = document.getElementById("gridToggle");
      gridToggle.addEventListener("change", () => {
        showGrid = gridToggle.checked;
        renderCanvas();
      });

      // Theme selector
      const themeSelect = document.getElementById("themeSelect");

      function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) return;

        currentTheme = themeName;

        // Update body background (fallback)
        document.body.style.background = theme.background;

        // Re-render canvas with new theme
        renderCanvas();

        // Update UI elements that need theme colors
        document.querySelectorAll("#modifiers .modifier").forEach((el) => {
          el.style.background =
            theme.ui === "#ffffff"
              ? "rgba(255,255,255,0.9)"
              : "rgba(0,0,0,0.8)";
          el.style.color = theme.ui === "#ffffff" ? "#000" : "#fff";
        });

        // Update help button
        const helpBtn = document.getElementById("helpBtn");
        helpBtn.style.borderColor = theme.ui;
        helpBtn.style.color = theme.ui;
      }

      themeSelect.addEventListener("change", () => {
        applyTheme(themeSelect.value);
      });

      // Stop all dots
      document.getElementById("stopAllBtn").addEventListener("click", () => {
        for (const [dotId, vel] of dotVelocities) {
          const dot = dots.find((d) => d.id === dotId);
          if (dot) {
            const snapped = snapToGrid(dot.x, dot.y);
            if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
              dot.x = snapped.x;
              dot.y = snapped.y;
            }
          }
        }
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        orbitingDots.clear();
        render();
      });

      // Save state
      document.getElementById("saveBtn").addEventListener("click", () => {
        const state = {
          dots: dots.map((d) => ({
            id: d.id,
            x: d.x,
            y: d.y,
            radius: d.radius,
            color: d.color,
            locked: d.locked,
          })),
          nextId: nextId,
          theme: currentTheme,
          settings: {
            dotsPerClick: countSlider.value,
            friction: frictionSlider.value,
            bounciness: bounceSlider.value,
            showGrid: gridToggle.checked,
          },
        };
        localStorage.setItem("dotsAppState", JSON.stringify(state));

        // Visual feedback
        const btn = document.getElementById("saveBtn");
        const originalText = btn.textContent;
        btn.textContent = "Saved!";
        setTimeout(() => {
          btn.textContent = originalText;
        }, 1000);
      });

      // Load state
      document.getElementById("loadBtn").addEventListener("click", () => {
        const saved = localStorage.getItem("dotsAppState");
        if (!saved) {
          const btn = document.getElementById("loadBtn");
          const originalText = btn.textContent;
          btn.textContent = "No save found";
          setTimeout(() => {
            btn.textContent = originalText;
          }, 1000);
          return;
        }

        try {
          const state = JSON.parse(saved);

          // Stop all current motion
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();

          // Restore dots
          dots = state.dots || [];
          nextId =
            state.nextId ||
            (dots.length > 0 ? Math.max(...dots.map((d) => d.id)) + 1 : 1);

          // Restore theme
          if (state.theme && themes[state.theme]) {
            themeSelect.value = state.theme;
            applyTheme(state.theme);
          }

          // Restore settings
          if (state.settings) {
            if (state.settings.dotsPerClick) {
              countSlider.value = state.settings.dotsPerClick;
              countValue.textContent = state.settings.dotsPerClick;
            }
            if (state.settings.friction) {
              frictionSlider.value = state.settings.friction;
              frictionValue.textContent = state.settings.friction;
            }
            if (state.settings.bounciness) {
              bounceSlider.value = state.settings.bounciness;
              bounceValue.textContent = state.settings.bounciness;
            }
            if (state.settings.showGrid !== undefined) {
              gridToggle.checked = state.settings.showGrid;
              showGrid = state.settings.showGrid;
            }
          }

          render();

          // Visual feedback
          const btn = document.getElementById("loadBtn");
          const originalText = btn.textContent;
          btn.textContent = "Loaded!";
          setTimeout(() => {
            btn.textContent = originalText;
          }, 1000);
        } catch (e) {
          console.error("Failed to load state:", e);
        }
      });

      // Clear all
      document.getElementById("clearBtn").addEventListener("click", () => {
        dots = [];
        dotVelocities.clear();
        noFrictionDots.clear();
        boostedDots.clear();
        // Reset orbit mode
        if (orbitMode) {
          orbitSunId = null;
          orbitingDots.clear();
          disableOrbitMode();
        }
        render();
      });

      // ========== KEYBOARD CONTROLS ==========
      const boostIndicator = document.getElementById("boostIndicator");
      const perpetualIndicator = document.getElementById("perpetualIndicator");
      const helpModal = document.getElementById("helpModal");

      window.addEventListener("keydown", (e) => {
        if (e.key === "a" || e.key === "A") {
          isBoostKeyHeld = true;
          boostIndicator.classList.add("active");
          document.getElementById("boostToggle").classList.add("active");
        }
        if (e.key === "c" || e.key === "C") {
          isNoFrictionKeyHeld = true;
          perpetualIndicator.classList.add("active");
          document.getElementById("perpetualToggle").classList.add("active");
        }
        if (e.key === "f" || e.key === "F") {
          isFrozen = !isFrozen;
          freezeToggle.checked = isFrozen;
          freezeIndicator.classList.toggle("active", isFrozen);
          if (isFrozen) {
            dotVelocities.clear();
            noFrictionDots.clear();
            boostedDots.clear();
          }
        }
        if (e.key === "p" || e.key === "P") {
          togglePaintMode();
        }
        if (e.key === "l" || e.key === "L") {
          toggleLockMode();
        }
        if (e.key === "o" || e.key === "O") {
          if (orbitMode) {
            disableOrbitMode();
          } else {
            enableOrbitMode();
          }
        }
        if (e.key === "s" || e.key === "S") {
          // Stop all dots (including orbiting ones)
          for (const [dotId, vel] of dotVelocities) {
            const dot = dots.find((d) => d.id === dotId);
            if (dot) {
              const snapped = snapToGrid(dot.x, dot.y);
              if (!wouldOverlap(snapped.x, snapped.y, dot.radius, dot.id)) {
                dot.x = snapped.x;
                dot.y = snapped.y;
              }
            }
          }
          dotVelocities.clear();
          noFrictionDots.clear();
          boostedDots.clear();
          orbitingDots.clear();
          render();
        }
        if (e.key === "?") {
          helpModal.classList.toggle("visible");
        }
        if (e.key === "Escape") {
          helpModal.classList.remove("visible");
          controlsPanel.classList.remove("open");
          // Exit paint mode
          if (paintMode) {
            paintMode = false;
            paintModeToggle.classList.remove("active");
            paintIndicator.classList.remove("active");
          }
          // Exit lock mode
          if (lockMode) {
            lockMode = false;
            lockModeToggle.classList.remove("active");
            lockIndicator.classList.remove("active");
          }
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "a" || e.key === "A") {
          isBoostKeyHeld = false;
          boostIndicator.classList.remove("active");
          document.getElementById("boostToggle").classList.remove("active");
        }
        if (e.key === "c" || e.key === "C") {
          isNoFrictionKeyHeld = false;
          perpetualIndicator.classList.remove("active");
          document.getElementById("perpetualToggle").classList.remove("active");
        }
      });

      // Help modal controls
      document.getElementById("helpBtn").addEventListener("click", () => {
        helpModal.classList.toggle("visible");
      });

      document.getElementById("closeHelp").addEventListener("click", () => {
        helpModal.classList.remove("visible");
      });

      helpModal.addEventListener("click", (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove("visible");
        }
      });

      // ========== GAME SCOREBOARD ==========
      let currentGame = "sandbox";
      let scoreboardOpen = false;

      // Toggle scoreboard open/closed
      document.getElementById("scoreboardToggle").addEventListener("click", () => {
        scoreboardOpen = !scoreboardOpen;
        document.getElementById("gameBoard").classList.toggle("open", scoreboardOpen);
      });

      // Get display name for game
      function getGameDisplayName(game) {
        const names = {
          sandbox: "Free Play",
          chain: "Chain",
          golf: "Golf",
          pinball: "Pinball",
          cluster: "Cluster"
        };
        return names[game] || game;
      }

      // Get current score for collapsed view
      function getCurrentScoreDisplay() {
        switch (currentGame) {
          case "chain":
            return chainReactionScore > 0 ? chainReactionScore.toString() : "";
          case "golf":
            return golfStrokes > 0 ? golfStrokes.toString() : "";
          case "pinball":
            return pinballScore > 0 ? pinballScore.toString() : "";
          case "cluster":
            return clusterTimeElapsed > 0 ? formatClusterTime(clusterTimeElapsed) : "";
          default:
            return dots.length > 0 ? dots.length.toString() : "";
        }
      }

      function switchGame(gameName) {
        // Exit current game
        if (currentGame !== gameName) {
          if (currentGame === "chain") {
            chainReactionToggle.checked = false;
            chainReactionToggle.dispatchEvent(new Event("change"));
          } else if (currentGame === "golf") {
            golfToggle.checked = false;
            golfToggle.dispatchEvent(new Event("change"));
          } else if (currentGame === "pinball") {
            pinballToggle.checked = false;
            pinballToggle.dispatchEvent(new Event("change"));
          } else if (currentGame === "cluster") {
            clusterToggle.checked = false;
            clusterToggle.dispatchEvent(new Event("change"));
          }
        }

        currentGame = gameName;

        // Update tabs
        document.querySelectorAll(".game-tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.game === gameName);
        });

        // Update content panels
        document.querySelectorAll(".scoreboard-content").forEach((panel) => {
          panel.classList.toggle("active", panel.dataset.game === gameName);
        });

        // Enter new game mode
        if (gameName === "chain") {
          chainReactionToggle.checked = true;
          chainReactionToggle.dispatchEvent(new Event("change"));
        } else if (gameName === "golf") {
          golfToggle.checked = true;
          golfToggle.dispatchEvent(new Event("change"));
        } else if (gameName === "pinball") {
          pinballToggle.checked = true;
          pinballToggle.dispatchEvent(new Event("change"));
        } else if (gameName === "cluster") {
          clusterToggle.checked = true;
          clusterToggle.dispatchEvent(new Event("change"));
        }

        updateScoreboard();
      }

      // Tab click handlers
      document.querySelectorAll(".game-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          switchGame(tab.dataset.game);
        });
      });

      // Scoreboard button handlers
      document.getElementById("chainStartBtn2").addEventListener("click", () => {
        if (chainReactionActive) return;
        chainWaitingForThrow = true;
        document.getElementById("chainStartBtn2").textContent = "Throw a dot!";
        document.getElementById("chainStatusText").textContent = "Throw any dot to start!";
      });

      document.getElementById("chainResetBtn2").addEventListener("click", () => {
        chainWaitingForThrow = false;
        document.getElementById("chainStartBtn2").textContent = "Start Chain";
        resetChainReaction();
        updateScoreboard();
      });

      document.getElementById("golfActionBtn").addEventListener("click", () => {
        if (golfHoleComplete) {
          nextGolfHole();
        } else if (golfBallId === null) {
          startGolfHole();
        }
        updateScoreboard();
      });

      document.getElementById("pinballActionBtn").addEventListener("click", () => {
        startPinballRound();
        updateScoreboard();
      });

      document.getElementById("clusterActionBtn").addEventListener("click", () => {
        startClusterRound();
        updateScoreboard();
      });

      // Update scoreboard display
      function updateScoreboard() {
        // Sandbox
        document.getElementById("sandboxDotCount").textContent = dots.length;

        // Chain
        document.getElementById("chainScoreMain").textContent = chainReactionScore;
        document.getElementById("chainTotalDots").textContent = dots.length;

        const chainPctBadge = document.getElementById("chainPctBadge");
        if (chainReactionActive || chainReactionScore > 0) {
          const pct = dots.length > 0 ? Math.round((chainReactionScore / dots.length) * 100) : 0;
          chainPctBadge.textContent = pct + "%";
          chainPctBadge.style.display = "inline-block";
        } else {
          chainPctBadge.style.display = "none";
        }

        if (chainReactionActive) {
          document.getElementById("chainStatusText").textContent = "Chain reaction in progress...";
          document.getElementById("chainStartBtn2").textContent = "In Progress";
        } else if (chainReactionScore > 0) {
          document.getElementById("chainStatusText").textContent = "Round complete!";
          document.getElementById("chainStartBtn2").textContent = "Start Chain";
        } else {
          document.getElementById("chainStatusText").textContent = "Place dots, then start";
          document.getElementById("chainStartBtn2").textContent = "Start Chain";
        }

        // Golf
        document.getElementById("golfHoleNum").textContent = "Hole " + golfHoleNumber;
        document.getElementById("golfParBadge").textContent = "PAR " + golfPar;
        document.getElementById("golfStrokesMain").textContent = golfStrokes;

        if (golfTotalScore === 0) {
          document.getElementById("golfTotalScore").textContent = "E";
        } else if (golfTotalScore > 0) {
          document.getElementById("golfTotalScore").textContent = "+" + golfTotalScore;
        } else {
          document.getElementById("golfTotalScore").textContent = golfTotalScore;
        }

        const golfActionBtn = document.getElementById("golfActionBtn");
        const golfResultText = document.getElementById("golfResultText");
        if (golfHoleComplete) {
          const diff = golfStrokes - golfPar;
          let msg = "";
          if (diff === -2) msg = "EAGLE!";
          else if (diff === -1) msg = "BIRDIE!";
          else if (diff === 0) msg = "PAR";
          else if (diff === 1) msg = "BOGEY";
          else if (diff === 2) msg = "DOUBLE BOGEY";
          else if (diff > 2) msg = "+" + diff;
          else msg = diff.toString();
          golfResultText.textContent = msg;
          golfActionBtn.textContent = "Next Hole";
        } else if (golfBallId !== null) {
          golfResultText.textContent = "";
          golfActionBtn.textContent = "Playing...";
        } else {
          golfResultText.textContent = "";
          golfActionBtn.textContent = "Start Hole";
        }

        // Pinball
        document.getElementById("pinballScoreMain").textContent = pinballScore;
        document.getElementById("pinballBestScore").textContent = pinballBest;

        const pinballActionBtn = document.getElementById("pinballActionBtn");
        if (pinballRoundActive) {
          pinballActionBtn.textContent = "Playing...";
        } else {
          pinballActionBtn.textContent = "Start Round";
        }

        // Cluster
        document.getElementById("clusterTimerMain").textContent = formatClusterTime(clusterTimeElapsed);
        document.getElementById("clusterBestTime").textContent = formatClusterTime(clusterBest);

        const clusterActionBtn = document.getElementById("clusterActionBtn");
        if (clusterRoundActive) {
          clusterActionBtn.textContent = "Survive!";
        } else {
          clusterActionBtn.textContent = clusterTimeElapsed > 0 ? "Try Again" : "Start";
        }

        // Update collapsed toggle display
        document.getElementById("toggleGameName").textContent = getGameDisplayName(currentGame);
        document.getElementById("toggleScoreValue").textContent = getCurrentScoreDisplay();
      }

      // Hook into existing update functions to refresh scoreboard
      const originalUpdateChainScoreDisplay = updateChainScoreDisplay;
      updateChainScoreDisplay = function () {
        originalUpdateChainScoreDisplay();
        updateScoreboard();
      };

      const originalUpdateGolfHUD = updateGolfHUD;
      updateGolfHUD = function () {
        originalUpdateGolfHUD();
        updateScoreboard();
      };

      const originalUpdatePinballHUD = updatePinballHUD;
      updatePinballHUD = function () {
        originalUpdatePinballHUD();
        updateScoreboard();
      };

      const originalUpdateClusterHUD = updateClusterHUD;
      updateClusterHUD = function () {
        originalUpdateClusterHUD();
        updateScoreboard();
      };

      // Update dot count periodically for sandbox mode
      setInterval(() => {
        if (currentGame === "sandbox") {
          document.getElementById("sandboxDotCount").textContent = dots.length;
        }
      }, 500);

      // Initial render
      render();
      updateScoreboard();
    </script>
  </body>
</html>
